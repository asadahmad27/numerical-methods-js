[{"F:\\numerical-methods-js\\src\\index.js":"1","F:\\numerical-methods-js\\src\\reportWebVitals.js":"2","F:\\numerical-methods-js\\src\\App.js":"3","F:\\numerical-methods-js\\src\\components\\utils.js":"4","F:\\numerical-methods-js\\src\\components\\NotFound.js":"5","F:\\numerical-methods-js\\src\\components\\ErrorBoundary.js":"6","F:\\numerical-methods-js\\src\\components\\menu\\Menu.js":"7","F:\\numerical-methods-js\\src\\constants\\categories.js":"8","F:\\numerical-methods-js\\src\\components\\menu\\Category.js":"9","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js":"10","F:\\numerical-methods-js\\src\\components\\header\\Header.js":"11","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js":"12","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js":"13","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js":"14","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js":"15","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js":"16","F:\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js":"17","F:\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js":"18","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js":"19","F:\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js":"20","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Secant.js":"21","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js":"22","F:\\numerical-methods-js\\src\\components\\menu\\MethodType.js":"23","F:\\numerical-methods-js\\src\\components\\Graph.js":"24","F:\\numerical-methods-js\\src\\components\\matrix_utils.js":"25","F:\\numerical-methods-js\\src\\components\\MethodInfo.js":"26","F:\\numerical-methods-js\\src\\components\\methods\\mainPage.js":"27","F:\\numerical-methods-js\\src\\components\\allMethods\\Bisection.js":"28","F:\\numerical-methods-js\\src\\components\\allMethods\\Finite.js":"29","F:\\numerical-methods-js\\src\\components\\allMethods\\Secant.js":"30","F:\\numerical-methods-js\\src\\components\\allMethods\\Newton.js":"31","F:\\numerical-methods-js\\src\\components\\allMethods\\Simpson.js":"32","F:\\numerical-methods-js\\src\\components\\allMethods\\JacobiSeidel.js":"33","F:\\numerical-methods-js\\src\\components\\allMethods\\Trapezoidal.js":"34","F:\\numerical-methods-js\\src\\components\\allMethods\\Euler.js":"35","F:\\numerical-methods-js\\src\\components\\allMethods\\Taylor.js":"36","F:\\numerical-methods-js\\src\\components\\allMethods\\Runge.js":"37"},{"size":1039,"mtime":1652551373134,"results":"38","hashOfConfig":"39"},{"size":375,"mtime":1652546807575,"results":"40","hashOfConfig":"39"},{"size":1858,"mtime":1652606917499,"results":"41","hashOfConfig":"39"},{"size":1896,"mtime":1652546807572,"results":"42","hashOfConfig":"39"},{"size":1927,"mtime":1652546807543,"results":"43","hashOfConfig":"39"},{"size":2419,"mtime":1652546807542,"results":"44","hashOfConfig":"39"},{"size":1884,"mtime":1652606917506,"results":"45","hashOfConfig":"39"},{"size":4378,"mtime":1652606787387,"results":"46","hashOfConfig":"39"},{"size":1432,"mtime":1652606894024,"results":"47","hashOfConfig":"39"},{"size":23742,"mtime":1652551486974,"results":"48","hashOfConfig":"39"},{"size":4738,"mtime":1652606917503,"results":"49","hashOfConfig":"39"},{"size":20952,"mtime":1652551513782,"results":"50","hashOfConfig":"39"},{"size":23465,"mtime":1652551513974,"results":"51","hashOfConfig":"39"},{"size":22153,"mtime":1652551320510,"results":"52","hashOfConfig":"39"},{"size":18736,"mtime":1652551513280,"results":"53","hashOfConfig":"39"},{"size":17414,"mtime":1652551513682,"results":"54","hashOfConfig":"39"},{"size":18421,"mtime":1652551515389,"results":"55","hashOfConfig":"39"},{"size":3682,"mtime":1652551511780,"results":"56","hashOfConfig":"39"},{"size":25570,"mtime":1652551513974,"results":"57","hashOfConfig":"39"},{"size":35756,"mtime":1652551515204,"results":"58","hashOfConfig":"39"},{"size":19263,"mtime":1652551514380,"results":"59","hashOfConfig":"39"},{"size":17799,"mtime":1652551513683,"results":"60","hashOfConfig":"39"},{"size":1164,"mtime":1652606917507,"results":"61","hashOfConfig":"39"},{"size":5367,"mtime":1652546807542,"results":"62","hashOfConfig":"39"},{"size":17495,"mtime":1652546807544,"results":"63","hashOfConfig":"39"},{"size":1278,"mtime":1652546807543,"results":"64","hashOfConfig":"39"},{"size":192,"mtime":1652598426790,"results":"65","hashOfConfig":"39"},{"size":23742,"mtime":1652605164451,"results":"66","hashOfConfig":"39"},{"size":18421,"mtime":1652551515389,"results":"67","hashOfConfig":"39"},{"size":19263,"mtime":1652606917501,"results":"68","hashOfConfig":"39"},{"size":17799,"mtime":1652551513683,"results":"69","hashOfConfig":"39"},{"size":18736,"mtime":1652551513280,"results":"70","hashOfConfig":"39"},{"size":35756,"mtime":1652551515204,"results":"71","hashOfConfig":"39"},{"size":17414,"mtime":1652551513682,"results":"72","hashOfConfig":"39"},{"size":22153,"mtime":1652605164449,"results":"73","hashOfConfig":"39"},{"size":23465,"mtime":1652551513974,"results":"74","hashOfConfig":"39"},{"size":20952,"mtime":1652551513782,"results":"75","hashOfConfig":"39"},{"filePath":"76","messages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},"pufcpd",{"filePath":"79","messages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"89","messages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"91","messages":"92","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"93","messages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"95","messages":"96","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97","usedDeprecatedRules":"78"},{"filePath":"98","messages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"100","messages":"101","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"78"},{"filePath":"103","messages":"104","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105","usedDeprecatedRules":"78"},{"filePath":"106","messages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"78"},{"filePath":"109","messages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111","usedDeprecatedRules":"78"},{"filePath":"112","messages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114","usedDeprecatedRules":"78"},{"filePath":"115","messages":"116","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117","usedDeprecatedRules":"78"},{"filePath":"118","messages":"119","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"120","messages":"121","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"122"},{"filePath":"123","messages":"124","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"125","usedDeprecatedRules":"78"},{"filePath":"126","messages":"127","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"78"},{"filePath":"129","messages":"130","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"131","usedDeprecatedRules":"78"},{"filePath":"132","messages":"133","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"134","messages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"136","usedDeprecatedRules":"78"},{"filePath":"137","messages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"139","messages":"140","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"141","messages":"142","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"143","messages":"144","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97","usedDeprecatedRules":"78"},{"filePath":"145","messages":"146","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"147","messages":"148","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"149","messages":"150","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"151","messages":"152","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"153","messages":"154","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"155","messages":"156","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"157","messages":"158","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"159","messages":"160","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"161","messages":"162","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"F:\\numerical-methods-js\\src\\index.js",[],["163","164"],"F:\\numerical-methods-js\\src\\reportWebVitals.js",[],"F:\\numerical-methods-js\\src\\App.js",["165"],"F:\\numerical-methods-js\\src\\components\\utils.js",[],"F:\\numerical-methods-js\\src\\components\\NotFound.js",[],"F:\\numerical-methods-js\\src\\components\\ErrorBoundary.js",[],"F:\\numerical-methods-js\\src\\components\\menu\\Menu.js",["166","167"],"F:\\numerical-methods-js\\src\\constants\\categories.js",[],"F:\\numerical-methods-js\\src\\components\\menu\\Category.js",["168","169","170","171","172","173"],"F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js",["174","175","176","177","178","179","180"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearBisection({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(0);\r\n    const [upperX, setUpperX] = useState(3);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be a number!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"Upper x must be a number!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.0005);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    else if (errorThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || thresholdError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    let results = [];\r\n    let iterations = 1;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let i = 0;\r\n        while (true) {\r\n            let oldLowerX = (i === 0) ? lowerX : results[i - 1].newLowerX;\r\n            let oldUpperX = (i === 0) ? upperX : results[i - 1].newUpperX;\r\n            let newLowerX = oldLowerX;\r\n            let newUpperX = oldUpperX;\r\n            let rootX = (newLowerX + newUpperX) / 2;\r\n            let lowerFuncResult, upperFuncResult, rootFuncResult, errorX;\r\n            let rootFound = false;\r\n            if (i !== 0) {\r\n                // Check if root error is lower than threshold\r\n                errorX = Math.abs(rootX - results[i - 1].rootX);\r\n                if (errorX < errorThreshold) {\r\n                    rootFound = true;\r\n                }\r\n            }\r\n            if (!rootFound) {\r\n                // Update lower and upper x values\r\n                try {\r\n                    lowerFuncResult = functionValue.evaluate({ x: oldLowerX });\r\n                    upperFuncResult = functionValue.evaluate({ x: oldUpperX }); // upperFuncResult is for visualisation purposes, no relevance in the calculations\r\n                    rootFuncResult = functionValue.evaluate({ x: rootX });\r\n                }\r\n                catch {\r\n                    hasError = true;\r\n                    functionError = true;\r\n                    functionErrorText = \"Only variable x is allowed!\";\r\n                    solve = false;\r\n                    break;\r\n                }\r\n                let product = lowerFuncResult * rootFuncResult;\r\n                if (product < 0) {\r\n                    newUpperX = rootX;\r\n                }\r\n                else if (product > 0) {\r\n                    newLowerX = rootX;\r\n                }\r\n                else {\r\n                    rootFound = true;\r\n                }\r\n            }\r\n\r\n            results.push({\r\n                oldLowerX,\r\n                newLowerX,\r\n                oldUpperX,\r\n                newUpperX,\r\n                rootX,\r\n                lowerFuncResult,\r\n                upperFuncResult,\r\n                rootFuncResult,\r\n                errorX,\r\n            });\r\n            i++;\r\n            if (rootFound) {\r\n                break;\r\n            }\r\n            if (i > 1000) {\r\n                exceedIterError = true;\r\n                exceedIterErrorText = \"Exceeded 1000 iterations!\";\r\n                break;\r\n            }\r\n        }\r\n        iterations = i;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, errorThreshold, iterations, exceedIterError, exceedIterErrorText, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, f(x):\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"errorThreshold-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Error threshold:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setErrorThreshold(parseFloat(event.target.value))}\r\n                                            error={thresholdError}\r\n                                            label={thresholdError ? \"Error\" : \"\"}\r\n                                            defaultValue={errorThreshold.toString()}\r\n                                            helperText={thresholdErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let oldLowerXLatex = String.raw`x_{lower_{${currentIteration - 1}}}`;\r\n        let oldUpperXLatex = String.raw`x_{upper_{${currentIteration - 1}}}`;\r\n        let newLowerXLatex = String.raw`x_{lower_{${currentIteration}}}`;\r\n        let newUpperXLatex = String.raw`x_{upper_{${currentIteration}}}`;\r\n        let newRootXLatex = String.raw`x_{root_{${currentIteration - 1}}}`;\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${oldLowerXLatex} &=& ${formatLatex(currentResult.oldLowerX)}\r\n        \\\\ ${oldUpperXLatex} &=& ${formatLatex(currentResult.oldUpperX)}\r\n        \\\\ ${newRootXLatex} &=& \\frac{${oldLowerXLatex} + ${oldUpperXLatex}}{2}\r\n        \\\\                       &=& ${formatLatex(currentResult.rootX)}\r\n        \\\\\r\n        `;\r\n        let rootFound = false;\r\n        if (currentIteration > 1) {\r\n            let oldRootXLatex = String.raw`x_{root_{${currentIteration - 2}}}`;\r\n            latexContent += String.raw`\r\n            \\\\ ${oldRootXLatex} &=& ${formatLatex(results[currentIteration - 2].rootX)}\r\n            \\\\ Error &=& |${newRootXLatex} - ${oldRootXLatex}|\r\n            \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n            \\\\\r\n            `;\r\n            if (currentResult.errorX < params.errorThreshold) {\r\n                rootFound = true;\r\n                latexContent += String.raw`\r\n                \\end{array}\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text{Root found because:}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ Error &<& Error Threshold\r\n                \\\\ ${formatLatex(currentResult.errorX)} &<& ${formatLatex(params.errorThreshold)}\r\n                `;\r\n            }\r\n        }\r\n        if (!rootFound) {\r\n            latexContent += String.raw`\r\n            \\\\ f(${oldLowerXLatex}) &=& ${formatLatex(currentResult.lowerFuncResult)}\r\n            \\\\ f(${newRootXLatex}) &=& ${formatLatex(currentResult.rootFuncResult)}\r\n            \\\\\r\n            \\\\\r\n            `;\r\n            let product = currentResult.lowerFuncResult * currentResult.rootFuncResult;\r\n            if (product < 0) {\r\n                latexContent += String.raw`\r\n                \\end{array}\r\n                \\\\ \\hline\r\n                \\\\ \\text{Given that } f(${oldLowerXLatex})f(${newRootXLatex}) < 0,\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${newLowerXLatex} &=& ${oldLowerXLatex}\r\n                \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n                \\\\ ${newUpperXLatex} &=& ${newRootXLatex}\r\n                \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n                `;\r\n            }\r\n            else if (product > 0) {\r\n                latexContent += String.raw`\r\n                \\end{array}\r\n                \\\\ \\hline\r\n                \\\\ \\text{Given that } f(${oldLowerXLatex})f(${newRootXLatex}) > 0,\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${newLowerXLatex} &=& ${newRootXLatex}\r\n                \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n                \\\\ ${newUpperXLatex} &=& ${oldUpperXLatex}\r\n                \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\end{array}\r\n                \\\\ \\hline\r\n                \\\\ \\text{Root found because }\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ f(${oldLowerXLatex})f(${newRootXLatex}) == 0.\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'lowerX', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"Lower\", showLabel: true, latex:\r\n                    `(${currentResult.oldLowerX}, ${currentResult.lowerFuncResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'upperX', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"Upper\", showLabel: true, latex:\r\n                    `(${currentResult.oldUpperX}, ${currentResult.upperFuncResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.rootX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n\r\n                    <Grid container xs item direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                        <Grid xs item className=\"iteration-slider\">\r\n                            <Slide direction=\"left\" triggerOnce>\r\n                                <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                    <Slider\r\n                                        orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                        onChange={(event, value) => setCurrentIteration(value)}\r\n                                        defaultValue={1}\r\n                                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                                        step={1}\r\n                                        marks\r\n                                        min={1}\r\n                                        max={params.iterations}\r\n                                        valueLabelDisplay=\"on\"\r\n                                    />\r\n\r\n                                </Box>\r\n                            </Slide>\r\n                        </Grid>\r\n                        <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"step-math\">\r\n                                <Zoom duration={500} triggerOnce>\r\n                                    <Card className={styleClasses.card}>\r\n                                        <CardContent className={styleClasses.cardContent}>\r\n                                            <Typography variant=\"h6\">\r\n                                                Iteration {currentIteration}:\r\n                                            </Typography>\r\n                                            <TeX math={latexContent} block />\r\n                                        </CardContent>\r\n                                    </Card>\r\n                                </Zoom>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"graph-button\">\r\n\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n//<MathComponent tex={latexContent}/>\r\nexport default NonlinearBisection;","F:\\numerical-methods-js\\src\\components\\header\\Header.js",["181","182","183","184","185","186","187","188","189","190","191","192","193"],"F:\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js",["194"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeRunge({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0, y: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const k1 = functionNode.evaluate({ x: currentX, y: currentY });\r\n            const k2 = functionNode.evaluate({ x: currentX + stepHalf, y: currentY + k1 * stepHalf });\r\n            const k3 = functionNode.evaluate({ x: currentX + stepHalf, y: currentY + k2 * stepHalf });\r\n            const k4 = functionNode.evaluate({ x: currentX + stepSize, y: currentY + k3 * stepSize });\r\n            const newY = currentY + stepSize / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                k1,\r\n                k2,\r\n                k3,\r\n                k4,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, initialVector, stepSize, iterations, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ k_1 &=& f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n        \\\\    &=& ${formatLatex(currentResult.k1)}\r\n        \\\\\r\n        \\\\ k_2 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_1 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k2)}\r\n        \\\\\r\n        \\\\ k_3 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_2 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k3)}\r\n        \\\\\r\n        \\\\ k_4 &=& f(x_{${currentIteration - 1}} + h, y_{${currentIteration - 1}} + k_1 \\cdot h)\r\n        \\\\    &=& ${formatLatex(currentResult.k4)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array} \\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeRunge;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js",["195","196","197"],"import { isValidMath, formatLatex, mathjsToLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix19 as initialMatrix, generateGridCallback, gridTo2DArray, numberFactorials } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the maximum differential order.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply this method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeTaylor({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`2xy`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0, y: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 10) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! It is limited to 10! for performance reasons.\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || orderError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let derivNodes = [functionNode];\r\n    let derivLatex = String.raw`\\displaystyle\r\n    \\begin{array}{l}\r\n    \\\\ y^{'} = ${functionLatex}\r\n    `;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        for (let i = 1; i < order; i++) {\r\n            derivNodes.push(derivative(derivNodes[i - 1], 'x'));\r\n            derivLatex += String.raw`\r\n            \\\\ y^{${`'`.repeat(i + 1)}} = ${mathjsToLatex(derivNodes[i])}`;\r\n        }\r\n        derivLatex += String.raw`\\end{array}`;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            let newY = currentY;\r\n            let derivResults = [];\r\n            for (let i = 1; i <= order; i++) {\r\n                const result = derivNodes[i - 1].evaluate({ x: currentX, y: currentY });\r\n                derivResults.push(result);\r\n                newY += Math.pow(stepSize, i) * result / numberFactorials[i];\r\n            }\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                derivResults,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, order, initialVector, stepSize, iterations, derivNodes, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"derivative-display\">\r\n                                <Box border={1} borderRadius={5} boxShadow={2}>\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                    <Collapse in={!functionError}>\r\n                                        {!functionError && <Fade triggerOnce>\r\n                                            <TeX math={derivLatex} block />\r\n                                        </Fade>}\r\n                                    </Collapse>\r\n                                </Box>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"order-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Order:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setOrder(parseInt(event.target.value))}\r\n                                            error={orderError}\r\n                                            label={orderError ? \"Error\" : \"\"}\r\n                                            defaultValue={order.toString()}\r\n                                            helperText={orderErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n\r\n        let formulaLatex = String.raw`h y_{${currentIteration - 1}}^{'}`;\r\n        let valuesLatex = String.raw`${params.stepSize} (${formatLatex(currentResult.derivResults[0])})`;\r\n        for (let i = 2; i <= params.order; i++) {\r\n            //derivLatex += String.raw`\\\\ y^{${`'`.repeat(i + 1)}} = ${mathjsToLatex(params.derivNodes[i])}`;\r\n            formulaLatex += String.raw`+ \\frac{h^{${i}}}{${i}!} y_{${currentIteration - 1}}^{${`'`.repeat(i)}}`;\r\n            valuesLatex += String.raw`+ \\frac{${params.stepSize}^{${i}}}{${numberFactorials[i]}} ( ${formatLatex(currentResult.derivResults[i - 1])} )`;\r\n        }\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + ${formulaLatex}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${valuesLatex}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        latexContent += String.raw`\r\n\r\n\r\n        `;\r\n        latexContent += String.raw`\r\n    \r\n        `\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeTaylor;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js",["198","199","200","201","202","203","204"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Checkbox from '@material-ui/core/Checkbox';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".heun-input\",\r\n        title: \"Heun's method\",\r\n        content:\r\n            \"If checked, Heun's method will be used instead of the default Euler's method.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Euler's method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeEuler({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Heun mode\r\n    const [heunMode, setHeunMode] = useState(true);\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0, y: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const functionResult = functionNode.evaluate({ x: currentX, y: currentY });\r\n            let functionResultHeun, tempY;\r\n            let newY = currentY + stepSize * functionResult;\r\n            if (heunMode) {\r\n                functionResultHeun = functionNode.evaluate({ x: newX, y: newY });\r\n                tempY = newY;\r\n                newY = currentY + stepSize / 2 * (functionResult + functionResultHeun);\r\n            }\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                tempY,\r\n                functionResult,\r\n                functionResultHeun\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, heunMode, initialVector, stepSize, iterations, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"heun-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <FormControlLabel\r\n                                    control={<Checkbox checked={heunMode} onChange={(event) => setHeunMode(event.target.checked)} name=\"heunMode\" />}\r\n                                    label=\"Use Heun's Method\"\r\n                                />\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        `;\r\n\r\n        if (params.heunMode) {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}}^{*} &=& y_{${currentIteration - 1}} + h \\cdot f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.tempY)}\r\n            \\end{array}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{2} ( f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}}) + f(x_{${currentIteration}}, y_{${currentIteration}}^{*}) )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${formatLatex(params.stepSize)}}{2} ( ${formatLatex(currentResult.functionResult)} + ${formatLatex(currentResult.functionResultHeun)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeEuler;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js",["205"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".subIntervals-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the number of subintervals, N, which must be even.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralSimpson({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Subintervals\r\n    const [subIntervals, setSubIntervals] = useState(10);\r\n    let subIntervalsError = false;\r\n    let subIntervalsErrorText = \"\";\r\n    if (isNaN(subIntervals) || !Number.isInteger(subIntervals) || subIntervals <= 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be a positive integer!\";\r\n    }\r\n    else if (subIntervals % 2 !== 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be an even integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || subIntervalsError;\r\n\r\n    // Solve\r\n    let latexContent, graphCallback;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        const width = (upperX - lowerX) / subIntervals;\r\n        let integralResult = 0;\r\n        let results = [];\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            const x = lowerX + i * width;\r\n            let f = functionValue.evaluate({ x: x });\r\n            if (i === 0 || i === subIntervals) {\r\n                integralResult += f;\r\n                results.push(f);\r\n            }\r\n            else {\r\n                if (i % 2 === 0) {\r\n                    integralResult += 2 * f;\r\n                    results.push(2 * f);\r\n                }\r\n                else {\r\n                    integralResult += 4 * f;\r\n                    results.push(4 * f);\r\n                }\r\n            }\r\n        }\r\n        integralResult *= width / 3;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& \\frac{ x_{upper} - x_{lower} }{N}\r\n        \\\\   &=& ${formatLatex(width)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ x_i = x_{lower} + i \\cdot h\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\frac{h}{3} [f(x_0) + 4 \\sum_{i=1, odd}^{${subIntervals - 1}} f(x_i) + 2 \\sum_{j=2, even}^{${subIntervals - 2}} f(x_j) + f(x_{${subIntervals}})]\r\n        \\\\`;\r\n        latexContent += String.raw`\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            let coefficient = \"\";\r\n            if (i > 0 && i < subIntervals) {\r\n                if (i % 2 === 0) {\r\n                    coefficient = \"2\";\r\n                }\r\n                else {\r\n                    coefficient = \"4\";\r\n                }\r\n            }\r\n            latexContent += String.raw`${coefficient}f(${formatLatex(lowerX + i * width)}) ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${formatLatex(results[i])} ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\" + functionLatex });\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\" + lowerX });\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\" + upperX });\r\n            calculator.current.setExpression({ id: 'n', latex: \"n=\" + subIntervals });\r\n            calculator.current.setExpression({ id: 'g', latex: String.raw`g\\left(x\\right)=f\\left(x\\right)\\left\\{a\\le x\\le b\\right\\}` });\r\n            calculator.current.setExpression({ id: 'shade', color: Desmos.Colors.BLACK, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,g\\left(x\\right)\\right)\\le y\\le\\max\\left(0,g\\left(x\\right)\\right)` });\r\n            calculator.current.setExpression({ id: 'i', latex: String.raw`i=\\left[1...n\\right]` });\r\n            calculator.current.setExpression({ id: 'sOdd', latex: String.raw`S_{i3}=\\left[2,4,...n\\right]` });\r\n            calculator.current.setExpression({ id: 'x1', latex: String.raw`x_{1}=a+\\left(S_{i3}-2\\right)\\frac{b-a}{n}` });\r\n            calculator.current.setExpression({ id: 'x2', latex: String.raw`x_{2}=a+\\left(S_{i3}-1\\right)\\frac{b-a}{n}` });\r\n            calculator.current.setExpression({ id: 'x3', latex: String.raw`x_{3}=a+S_{i3}\\frac{b-a}{n}` });\r\n            calculator.current.setExpression({ id: 'simpsonShade', color: Desmos.Colors.RED, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,P\\left(x\\right)\\right)\\le y\\le\\max\\left(0,P\\left(x\\right)\\right)\\left\\{x_{1}\\le x\\le x_{3}\\right\\}` });\r\n            calculator.current.setExpression({ id: 'xLine1', color: Desmos.Colors.RED, latex: String.raw`x=a+\\left(i-1\\right)\\frac{b-a}{n}\\left\\{\\min\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\le y\\le\\max\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\right\\}` });\r\n            calculator.current.setExpression({ id: 'xLine2', color: Desmos.Colors.RED, latex: String.raw`x=b\\left\\{\\min\\left(0,f\\left(b\\right)\\right)\\le y\\le\\max\\left(0,f\\left(b\\right)\\right)\\right\\}` });\r\n            calculator.current.setExpression({ id: 'sn', latex: String.raw`S_{n}=\\frac{1}{3}\\cdot\\frac{b-a}{n}\\left(f\\left(a\\right)+\\sum_{t=1}^{\\frac{n}{2}}4f\\left(a+\\left(2t-1\\right)\\frac{b-a}{n}\\right)+\\sum_{t=1}^{\\frac{n}{2}-1}2f\\left(a+2t\\frac{b-a}{n}\\right)+f\\left(b\\right)\\right)` });\r\n            calculator.current.setExpression({ id: 'p', latex: String.raw`P\\left(x\\right)=f\\left(x_{1}\\right)\\cdot\\frac{x-x_{2}}{x_{1}-x_{2}}\\cdot\\frac{x-x_{3}}{x_{1}-x_{3}}+f\\left(x_{2}\\right)\\cdot\\frac{x-x_{1}}{x_{2}-x_{1}}\\cdot\\frac{x-x_{3}}{x_{2}-x_{3}}+f\\left(x_{3}\\right)\\cdot\\frac{x-x_{1}}{x_{3}-x_{1}}\\cdot\\frac{x-x_{2}}{x_{3}-x_{2}}\\left\\{x_{1}\\le x\\le x_{3}\\right\\}` });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            If even subintervals, 2nd order polynomial/parabola.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"subIntervals-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Subintervals, N:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setSubIntervals(parseInt(event.target.value))}\r\n                                            error={subIntervalsError}\r\n                                            label={subIntervalsError ? \"Error\" : \"\"}\r\n                                            defaultValue={subIntervals.toString()}\r\n                                            helperText={subIntervalsErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item className=\"graph-button\">\r\n\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralSimpson;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js",["206"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".subIntervals-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the number of subintervals, N.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralTrapezoidal({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Subintervals\r\n    const [subIntervals, setSubIntervals] = useState(10);\r\n    let subIntervalsError = false;\r\n    let subIntervalsErrorText = \"\";\r\n    if (isNaN(subIntervals) || !Number.isInteger(subIntervals) || subIntervals <= 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || subIntervalsError;\r\n\r\n    // Solve\r\n    let latexContent, graphCallback;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        const width = (upperX - lowerX) / subIntervals;\r\n        let integralResult = 0;\r\n        let results = [];\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            const x = lowerX + i * width;\r\n            let f = functionValue.evaluate({ x: x });\r\n            if (i === 0 || i === subIntervals) {\r\n                integralResult += f;\r\n                results.push(f);\r\n            }\r\n            else {\r\n                integralResult += 2 * f;\r\n                results.push(2 * f);\r\n            }\r\n        }\r\n        integralResult *= width / 2;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& \\frac{ x_{upper} - x_{lower} }{N}\r\n        \\\\   &=& ${formatLatex(width)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ x_i = x_{lower} + i \\cdot h\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\frac{h}{2} [f(x_0) + 2 \\sum_{i=1}^{${subIntervals - 1}} f(x_i) + f(x_{${subIntervals}})]\r\n        \\\\`;\r\n        latexContent += String.raw`\r\n        \\\\ &=& ${formatLatex(width / 2)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${i === 0 || i === subIntervals ? \"\" : \"2\"}f(${formatLatex(lowerX + i * width)}) ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(width / 2)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${formatLatex(results[i])} ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\" + functionLatex });\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\" + lowerX });\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\" + upperX });\r\n            calculator.current.setExpression({ id: 'N', latex: \"N=\" + subIntervals });\r\n            calculator.current.setExpression({ id: 'L', latex: String.raw`L=\\left[a,\\ a+\\frac{\\left(b-a\\right)}{N},\\ a+\\frac{2\\left(b-a\\right)}{N},...,a+\\frac{\\left(N-1\\right)\\left(b-a\\right)}{N}\\right]` });\r\n            calculator.current.setExpression({ id: 'R', latex: String.raw`R=\\left[a+\\frac{\\left(b-a\\right)}{N},a+\\frac{2\\left(b-a\\right)}{N},\\ ...,b\\right]` });\r\n            calculator.current.setExpression({ id: 'M', latex: String.raw`M=\\frac{\\left(f\\left(R\\right)-f\\left(L\\right)\\right)}{R-L}` });\r\n            calculator.current.setExpression({ id: 'm', latex: String.raw`m=\\left[a+\\frac{.5\\left(b-a\\right)}{N},a+\\frac{3}{2}\\cdot\\frac{\\left(b-a\\right)}{N},...,b-\\frac{\\left(\\frac{1}{2}\\right)\\left(b-a\\right)}{N}\\right]` });\r\n            calculator.current.setExpression({ id: 'x', color: Desmos.Colors.BLACK, latex: String.raw`x=L\\left\\{\\min\\left(0,f\\left(L\\right)\\right)<y<\\max\\left(0,f\\left(L\\right)\\right)\\right\\}` });\r\n            calculator.current.setExpression({ id: 'positive', color: Desmos.Colors.GREEN, latex: String.raw`0\\le y\\le M\\left(x-L\\right)+f\\left(L\\right)\\left\\{L\\le x\\le R\\right\\}` });\r\n            calculator.current.setExpression({ id: 'negative', color: Desmos.Colors.RED, latex: String.raw`0\\ge y\\ge M\\left(x-L\\right)+f\\left(L\\right)\\left\\{L\\le x\\le R\\right\\}` });\r\n            /*\r\n            for (let i = 0; i <= subIntervals; i++) {\r\n                const x = lowerX + i * width;\r\n                let v = results[i];\r\n                if (i > 0 && i < subIntervals) {\r\n                    v /= 2;\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLACK, pointStyle: Desmos.Styles.POINT, label: i + 1, showLabel: subIntervals < 20, latex: String.raw`(${x}, ${v})`});\r\n            }\r\n            */\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"subIntervals-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Subintervals, N:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setSubIntervals(parseInt(event.target.value))}\r\n                                            error={subIntervalsError}\r\n                                            label={subIntervalsError ? \"Error\" : \"\"}\r\n                                            defaultValue={subIntervals.toString()}\r\n                                            helperText={subIntervalsErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item className=\"graph-button\">\r\n\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralTrapezoidal;","F:\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js",["207","208"],"import { isValidMath, mathjsKeywords, mathjsToLatex, formatLatex } from \"../../utils\";\r\nimport { getBinomialCoefficient } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect, useMemo } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".x-input\",\r\n        title: \"X value\",\r\n        content:\r\n            \"Specify the value of x at which to evaluate.\",\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the differential order to evaluate.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction DiffFinite({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`3x^5+2x^3-8`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // x values\r\n    const [xInput, setXInput] = useState(1.5);\r\n    let xInputError = false;\r\n    let xInputErrorText = \"\";\r\n    if (isNaN(xInput)) {\r\n        xInputError = true;\r\n        xInputErrorText = \"x value cannot be empty!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 14) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! Due to the factorial nature of the finite difference, the browser will lag or crash if it attempts to compute this.\";\r\n    }\r\n\r\n    // Step Size\r\n    const [stepSize, setStepSize] = useState(0.01);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize) || stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size cannot be negative or zero!\";\r\n    }\r\n\r\n    let hasError = functionError || xInputError || orderError || stepSizeError;\r\n\r\n    // Solve\r\n    let latexContent;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let derivValue = derivative(functionValue, 'x');\r\n        for (let i = 0; i < order - 1; i++) {\r\n            derivValue = derivative(derivValue, 'x');\r\n        }\r\n        const evaluateFunction = (forward, offset) => {\r\n            const step = offset * stepSize;\r\n            return forward ? functionValue.evaluate({ x: xInput + step }) : functionValue.evaluate({ x: xInput - step });\r\n        }\r\n\r\n        const denominator = Math.pow(stepSize, order);\r\n        let forwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n        }\r\n        let backwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n        }\r\n        let centralDiff = 0;\r\n        if (order > 1) {\r\n            for (let i = 0; i <= order; i++) {\r\n                centralDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(true, order / 2 - i) / denominator;\r\n            }\r\n        }\r\n        else {\r\n            // To adhere to lecturer's annoying convention\r\n            centralDiff = (evaluateFunction(true, 1) - evaluateFunction(false, 1)) / (2 * stepSize);\r\n        }\r\n\r\n        const correctDerivative = derivValue.evaluate({ x: xInput });\r\n\r\n        const forwardError = Math.abs(correctDerivative - forwardDiff);\r\n        const backwardError = Math.abs(correctDerivative - backwardDiff);\r\n        const centralError = Math.abs(correctDerivative - centralDiff);\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ f^{${order}}(x) &=& ${mathjsToLatex(derivValue)}\r\n        \\\\                 &=& ${formatLatex(correctDerivative)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Forward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{${order}-i} \\dbinom{${order}}{i} f(x+ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            //forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, order - i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, i))}) ${i === order ? '' : '+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(forwardDiff)}\r\n        \\end{array}\r\n        `;\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Backward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x-ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            // backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(false, i))}) ${i === order ? '' : '+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(backwardDiff)}\r\n        \\end{array}\r\n        `;\r\n\r\n        if (order === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{2h} [f(x+h) - f(x-h)]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(2 * stepSize)}} [${formatLatex(evaluateFunction(true, 1))} - ${formatLatex(evaluateFunction(false, 1))} ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{h^{${order}}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x+(\\frac{n}{2}-i)h) \\right]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(stepSize)}^{${order}}} [\r\n            `;\r\n            for (let i = 0; i <= order; i++) {\r\n                latexContent += String.raw`\r\n                (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, order / 2 - i))}) ${i === order ? '' : '+'}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Percentage Error} &=& |Actual - Estimate|\r\n        \\\\\r\n        \\\\ E_{Forward} &=& ${formatLatex(forwardError)}\r\n        \\\\ E_{Backward} &=& ${formatLatex(backwardError)}\r\n        \\\\ E_{Central} &=& ${formatLatex(centralError)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"x-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            x:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setXInput(parseFloat(event.target.value))}\r\n                                            error={xInputError}\r\n                                            label={xInputError ? \"Error\" : \"\"}\r\n                                            defaultValue={xInput.toString()}\r\n                                            helperText={xInputErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"order-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Order:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setOrder(parseInt(event.target.value))}\r\n                                            error={orderError}\r\n                                            label={orderError ? \"Error\" : \"\"}\r\n                                            defaultValue={order.toString()}\r\n                                            helperText={orderErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default DiffFinite;","F:\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js",["209","210","211","212","213"],"F:\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js",[],["214","215"],"F:\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js",["216","217","218"],"import { formatLatex, formatMatrixLatex } from \"../../utils\";\r\nimport {\r\n    initialMatrix3 as initialMatrix, initialInputColumn3 as initialInputColumn, initialOutputColumn3 as initialOutputColumn,\r\n    generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, cloneArray,\r\n    isDiagonallyDominant, numberFactorials, nextPermutation, generatePermutationMapping, matrixToLatex\r\n} from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Link from '@material-ui/core/Link';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n            \"Choose either Jacobi or Gauss-Seidel.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-size-input\",\r\n        title: \"Size\",\r\n        content:\r\n            \"Increase/Reduce the matrix's size\",\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n            \"Specify the matrix here.\",\r\n    },\r\n    {\r\n        target: \".input-col-input\",\r\n        title: \"Input\",\r\n        content:\r\n            \"Specify the initial input vector.\",\r\n    },\r\n    {\r\n        target: \".output-col-input\",\r\n        title: \"Output\",\r\n        content:\r\n            \"Specify the output vector.\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearJacobiSeidel({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const [inputColumnState, setInputColumnState] = useState(initialInputColumn);\r\n    const [outputColumnState, setOutputColumnState] = useState(initialOutputColumn);\r\n    const sizeCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            const inputColumns = inputColumnState.columns.slice();\r\n            const inputRows = inputColumnState.rows.slice();\r\n            const outputColumns = outputColumnState.columns.slice();\r\n            const outputRows = outputColumnState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                rows.push(createNewRow(gridState.columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n                inputColumns.push(createNewColumn(inputColumns.length));\r\n                inputRows[0][`col_${inputColumns.length}`] = 0;\r\n                outputColumns.push(createNewColumn(outputColumns.length));\r\n                outputRows[0][`col_${outputColumns.length}`] = 0;\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n                for (let i = 0; i < outputRows.length; i++) {\r\n                    delete outputRows[i][`col_${outputColumns.length}`];\r\n                }\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n                for (let i = 0; i < inputRows.length; i++) {\r\n                    delete inputRows[i][`col_${inputColumns.length}`];\r\n                }\r\n                inputColumns.pop();\r\n                outputColumns.pop();\r\n            }\r\n            setGridState({ columns, rows });\r\n            setInputColumnState({ columns: inputColumns, rows: inputRows });\r\n            setOutputColumnState({ columns: outputColumns, rows: outputRows });\r\n        };\r\n    }\r\n\r\n    // Solver Type\r\n    const [solverType, setSolverType] = useState(\"jacobi\");\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.0002);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    else if (errorThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = thresholdError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const originalOutput = gridTo2DArray(outputColumnState.rows)[0];\r\n    const originalInput = gridTo2DArray(inputColumnState.rows)[0];\r\n    let modifiedInput = cloneArray(originalInput);\r\n    const matrixSize = gridState.rows.length;\r\n    let results = [];\r\n    let iterations = 0;\r\n    let permutated = false;\r\n    let triedPermutating = false; // Failed to obtain a dominant matrix even after permutating.\r\n    if (!hasError) {\r\n        solve = true;\r\n        let dominant = false; // Strictly diagonally dominant\r\n        let modifiedMatrix = cloneArray(originalMatrix);\r\n        let modifiedOutput = cloneArray(originalOutput);\r\n        console.log(\"Original: \", modifiedMatrix);\r\n        if (!isDiagonallyDominant(modifiedMatrix)) {\r\n            console.log(\"Initially not dominant!\");\r\n            let numPermutations = numberFactorials[matrixSize];\r\n            let rowIndexes = [...Array(matrixSize).keys()];\r\n            for (let i = 0; i < numPermutations - 1; i++) {\r\n                nextPermutation(rowIndexes);\r\n                const permutatedMatrix = rowIndexes.map(ind => modifiedMatrix[ind]);\r\n                if (isDiagonallyDominant(permutatedMatrix)) {\r\n                    dominant = true;\r\n                    modifiedMatrix = permutatedMatrix;\r\n                    modifiedOutput = rowIndexes.map(ind => modifiedOutput[ind]);\r\n                    console.log(\"Found a dominant!\", modifiedMatrix, modifiedOutput, rowIndexes);\r\n                    break;\r\n                }\r\n            }\r\n            if (dominant) {\r\n                results.push({\r\n                    newMatrix: cloneArray(modifiedMatrix),\r\n                    newOutput: cloneArray(modifiedOutput),\r\n                    newInput: cloneArray(modifiedInput),\r\n                    permutated: true,\r\n                    rowIndexes: rowIndexes,\r\n                });\r\n                permutated = true;\r\n                iterations += 1;\r\n            }\r\n            else {\r\n                console.log(\"Tried permutating but failed!\");\r\n                triedPermutating = true;\r\n            }\r\n        }\r\n        else {\r\n            console.log(\"Initially dominant!\");\r\n            dominant = true;\r\n        }\r\n\r\n        if (dominant) {\r\n            console.log(\"Solve Dominant!\");\r\n            let i = 0;\r\n            while (true) {\r\n                let oldInput = (i === 0) ? originalInput : results[i - 1 + iterations].newInput;\r\n                let newInput = [];\r\n                for (let j = 0; j < matrixSize; j++) {\r\n                    let sum = modifiedOutput[j];\r\n                    if (solverType === \"jacobi\") {\r\n                        for (let k = 0; k < matrixSize; k++) {\r\n                            if (k !== j) {\r\n                                sum -= modifiedMatrix[j][k] * oldInput[k];\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (let k = 0; k < matrixSize; k++) {\r\n                            if (k < j) {\r\n                                sum -= modifiedMatrix[j][k] * newInput[k];\r\n                            }\r\n                            else if (k > j) {\r\n                                sum -= modifiedMatrix[j][k] * oldInput[k];\r\n                            }\r\n                        }\r\n                    }\r\n                    sum /= modifiedMatrix[j][j];\r\n                    newInput.push(sum);\r\n                }\r\n                let errorInput = newInput.map((v, index) => Math.abs(v - oldInput[index]));\r\n                let converged = true;\r\n                for (let j = 0; j < matrixSize; j++) {\r\n                    if (errorInput[j] >= errorThreshold) {\r\n                        converged = false;\r\n                        break;\r\n                    }\r\n                }\r\n                results.push({\r\n                    oldInput,\r\n                    newInput,\r\n                    errorInput,\r\n                    converged,\r\n                });\r\n\r\n                i++;\r\n                if (converged) {\r\n                    console.log(\"Converged\");\r\n                    break;\r\n                }\r\n                if (i > 1000) {\r\n                    console.log(\"Exceeded 1000 iterations!\");\r\n                    exceedIterError = true;\r\n                    exceedIterErrorText = \"Exceeded 1000 iterations! Try increasing the error threshold.\";\r\n                    break;\r\n                }\r\n            }\r\n            iterations += i;\r\n        }\r\n    }\r\n    console.log(results);\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { solverType, originalMatrix, originalInput, originalOutput, matrixSize, errorThreshold, iterations, exceedIterError, exceedIterErrorText, results, permutated, triedPermutating };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied to matrices in the form of\r\n                            <TeX math={String.raw`\\ Ax=B`} /> .\r\n                            <br />\r\n                            Warning: The process of finding a diagonally-dominant form may be slow for matrices 7x7 and beyond\r\n                            <br />\r\n                            because it needs to search through all the possible permutations.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"h6\">\r\n                                                    Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                                </Typography>\r\n                                                <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event) => setSolverType(event.target.value)}>\r\n                                                    <FormControlLabel value=\"jacobi\" control={<Radio />} label=\"Jacobi\" />\r\n                                                    <FormControlLabel value=\"seidel\" control={<Radio />} label=\"Gauss-Seidel\" />\r\n                                                </RadioGroup>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"matrix-size-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"h6\">\r\n                                                    Size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                                </Typography>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(false)} >\r\n                                                    <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                                </IconButton>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(true)} >\r\n                                                    <AddCircleOutlineOutlinedIcon />\r\n                                                </IconButton>\r\n                                            </Grid>\r\n\r\n                                            <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Matrix, A:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={0} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={gridState.columns}\r\n                                                            rowGetter={i => gridState.rows[i]}\r\n                                                            rowsCount={gridState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n\r\n                                            <Grid xs item className=\"input-col-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Initial Input, <TeX math={String.raw`X^{(0)}`} />:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={inputColumnState.columns}\r\n                                                            rowGetter={i => inputColumnState.rows[i]}\r\n                                                            rowsCount={inputColumnState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(inputColumnState, setInputColumnState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * inputColumnState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * inputColumnState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"output-col-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Output, B:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={2} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={outputColumnState.columns}\r\n                                                            rowGetter={i => outputColumnState.rows[i]}\r\n                                                            rowsCount={outputColumnState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(outputColumnState, setOutputColumnState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * outputColumnState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * outputColumnState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"errorThreshold-input\">\r\n                                                <Card className={styleClasses.card}>\r\n                                                    <CardContent className={styleClasses.cardContent}>\r\n                                                        <Typography variant=\"h6\">\r\n                                                            Error threshold:\r\n                                                        </Typography>\r\n                                                        <TextField\r\n                                                            disabled={false}\r\n                                                            type=\"number\"\r\n                                                            onChange={(event) => setErrorThreshold(parseFloat(event.target.value))}\r\n                                                            error={thresholdError}\r\n                                                            label={thresholdError ? \"Error\" : \"\"}\r\n                                                            defaultValue={errorThreshold.toString()}\r\n                                                            helperText={thresholdErrorText}\r\n                                                            variant=\"outlined\"\r\n                                                        />\r\n                                                    </CardContent>\r\n                                                </Card>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ smallScreen, params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n    let latexContent;\r\n\r\n    if (currentIteration <= 0) {\r\n        setCurrentIteration(1);\r\n    }\r\n    else if (params.iterations > 0 && currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else if (params.triedPermutating) {\r\n        // Failed even after permutating the matrix\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\text{Cannot find a diagonally dominant matrix.}\r\n        \\\\ \\overbrace{${matrixToLatex(params.originalMatrix, { leftBracketOnly: true })}}^{A}\r\n           \\overbrace{${matrixToLatex(params.originalInput, { single: true })}}^{X_{0}}\r\n        &=&\\overbrace{${matrixToLatex(params.originalOutput, { single: true })}}^{B}\r\n        \\end{array}\r\n        `;\r\n    }\r\n    else if (params.iterations > 0) {\r\n        let results = params.results;\r\n        let currentResult = results[currentIteration - 1];\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\begin{array}{lcl}\r\n        `;\r\n        if (currentResult.permutated) {\r\n            const permutationMapping = generatePermutationMapping(currentResult.rowIndexes);\r\n            const boldRows = Object.keys(permutationMapping).map((v) => parseInt(v) + 1);\r\n            boldRows.push(...Object.values(permutationMapping).map((v) => v + 1));\r\n            const previousLatex = String.raw`\r\n            \\overbrace{${matrixToLatex(params.originalMatrix, { leftBracketOnly: true, boldRows: boldRows })}}^{A}\r\n            \\overbrace{${matrixToLatex(params.originalOutput, { single: true, rightBracketOnly: true, boldRows: boldRows })}}^{B}`;\r\n            let operationLatex = String.raw`\\begin{array}{l}`;\r\n            for (const [key, value] of Object.entries(permutationMapping)) {\r\n                operationLatex += String.raw`R_{${parseInt(key) + 1}} \\leftrightarrow R_{${value + 1}}\\\\`;\r\n            }\r\n            operationLatex += String.raw`\\end{array}`;\r\n            const newLatex = String.raw`\r\n            \\overbrace{${matrixToLatex(currentResult.newMatrix, { leftBracketOnly: true, boldRows: boldRows })}}^{A}\r\n            \\overbrace{${matrixToLatex(currentResult.newOutput, { single: true, rightBracketOnly: true, boldRows: boldRows })}}^{B}`;\r\n            latexContent += String.raw`\r\n            \\\\ \\text{The matrix's rows are } \\textbf{permutated} ${smallScreen ? \"\\\\\\\\\" : \"\"} \\text{ to make it } \\textbf{strictly diagonally dominant.}\r\n            \\\\`\r\n            if (smallScreen) {\r\n                latexContent += String.raw`\r\n                \\\\ ${previousLatex}\r\n                \\\\ \\begin{array}{lcl}\r\n                    & \\downarrow &\r\n                    \\\\ & ${operationLatex} &\r\n                    \\\\ & \\downarrow &\r\n                    \\end{array}\r\n                \\\\ ${newLatex}\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ ${previousLatex}\r\n                    & \\overrightarrow{${operationLatex}}\r\n                    & ${newLatex}\r\n                    \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            let index = params.permutated ? currentIteration - 1 : currentIteration;\r\n            let matrix = params.permutated ? results[0].newMatrix : params.originalMatrix;\r\n            let output = params.permutated ? results[0].newOutput : params.originalOutput;\r\n            let solverExpressionLatex = params.solverType === \"jacobi\" ?\r\n                String.raw`\r\n            X^{(${index})}_i &=& \\frac{1}{A_{ii}}\r\n                \\left[ B_i - \\sum_{\\substack{j = 1, \\\\ j \\ne i}}^n \\left( A_{ij} \\cdot X^{(${index - 1})}_j \\right)\r\n                \\right]`\r\n                :\r\n                String.raw`\r\n            X^{(${index})}_i &=& \\frac{1}{A_{ii}}\r\n                \\left[ B_i - \\sum_{\\substack{j = 1}}^{i-1} \\left( A_{ij} \\cdot X^{(${index})}_j \\right)\r\n                           - \\sum_{\\substack{j = i+1}}^{n} \\left( A_{ij} \\cdot X^{(${index - 1})}_j \\right)\r\n\r\n                \\right]`;\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\overbrace{${matrixToLatex(matrix, { leftBracketOnly: true })}}^{A}\r\n            \\overbrace{${matrixToLatex(currentResult.oldInput, { single: true })}}^{X^{(${index - 1})}}\r\n            = \\overbrace{${matrixToLatex(output, { single: true })}}^{B}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${solverExpressionLatex}\r\n            \\\\\r\n            \\\\ &=& \\left[\\begin{matrix}\r\n            `;\r\n            for (let i = 0; i < params.matrixSize; i++) {\r\n                latexContent += String.raw`\\frac{1}{${formatMatrixLatex(matrix[i][i])}} \\left[ ${formatMatrixLatex(output[i])}`;\r\n                if (params.solverType === \"jacobi\") {\r\n                    for (let j = 0; j < params.matrixSize; j++) {\r\n                        if (j !== i) {\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.oldInput[j])}) `;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (let j = 0; j < params.matrixSize; j++) {\r\n                        if (j < i) {\r\n                            //sum -= modifiedMatrix[i][j] * newInput[j];\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.newInput[j])}) `;\r\n                        }\r\n                        else if (j > i) {\r\n                            //sum -= modifiedMatrix[i][j] * oldInput[j];\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.oldInput[j])}) `;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                latexContent += String.raw`\\right] \\cr`;\r\n            }\r\n\r\n            latexContent += String.raw`\r\n            \\end{matrix}\\right]\r\n            \\\\\r\n            \\\\ X^{(${index})} &=& ${matrixToLatex(currentResult.newInput, { single: true })}\r\n            \\end{array}\r\n            `;\r\n            if (results[0].permutated) {\r\n                // Reorder the equations\r\n                let restoredOutput = cloneArray(currentResult.newInput);\r\n                restoredOutput = results[0].rowIndexes.map(ind => restoredOutput[ind]);\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text {Given that the matrix A has been permutated in iteration 1, }\r\n                \\\\ \\text {we must restore it to the original order:}\r\n                \\\\\r\n                \\\\ X^{(${index})}_{restored} = ${matrixToLatex(restoredOutput, { single: true })}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ Error &=& |X^{(${index})} - X^{(${index - 1})}|\r\n            \\\\       &=& |${formatLatex(currentResult.errorInput)}|\r\n            \\end{array}\r\n            `;\r\n            if (currentResult.converged) {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text{Converged because:}\r\n                \\\\\r\n                \\\\ Error < Error Threshold\r\n                \\\\ ${formatLatex(currentResult.errorInput)} < ${formatLatex(params.errorThreshold)}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n    }\r\n    else {\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Cannot do anything.}\r\n        \\\\ \\overbrace{${matrixToLatex(params.originalMatrix, { leftBracketOnly: true })}}^{A}\r\n           \\overbrace{${matrixToLatex(params.originalInput, { single: true })}}^{X_{0}}\r\n        &=&\\overbrace{${matrixToLatex(params.originalOutput, { single: true })}}^{B}\r\n        \\end{array}\r\n        `;\r\n    }\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={currentIteration}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations <= 0 ? 1 : params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iteration {currentIteration}:\r\n                                    </Typography>\r\n                                    <TeX math={latexContent} />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default LinearJacobiSeidel;","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Secant.js",["219"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".perturbation-input\",\r\n        title: \"Perturbation\",\r\n        content:\r\n            \"Specify the perturbation fraction. Higher values produce a better approximation.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the modified secant method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearSecant({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Perturbation\r\n    const [perturbation, setPerturbation] = useState(0.01);\r\n    let perturbationError = false;\r\n    let perturbationErrorText = \"\";\r\n    if (perturbation <= 0) {\r\n        perturbationError = true;\r\n        perturbationErrorText = \"Perturbation must be a positive integer!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(3.5);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || perturbationError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX : results[i - 1].newX;\r\n            let perturbedX = previousX * (1 + perturbation);\r\n            let funcResult, funcResult2;\r\n            try {\r\n                funcResult = functionValue.evaluate({ x: previousX });\r\n                funcResult2 = functionValue.evaluate({ x: perturbedX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n\r\n            let newX = previousX - perturbation * previousX * funcResult / (funcResult2 - funcResult);\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                perturbedX,\r\n                funcResult,\r\n                funcResult2,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, perturbation, iterations, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, f(x):\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"perturbation-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Perturbation fraction, <TeX math={String.raw`\\delta`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setPerturbation(parseFloat(event.target.value))}\r\n                                            error={perturbationError}\r\n                                            label={perturbationError ? \"Error\" : \"\"}\r\n                                            defaultValue={perturbation.toString()}\r\n                                            helperText={perturbationErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialX-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial value, <TeX math={String.raw`x_0`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setInitialX(parseFloat(event.target.value))}\r\n                                            error={initialXError}\r\n                                            label={initialXError ? \"Error\" : \"\"}\r\n                                            defaultValue={initialX.toString()}\r\n                                            helperText={initialXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let perturbedXLatex = String.raw`${previousXLatex} + \\delta \\cdot ${previousXLatex}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ ${perturbedXLatex} &=& ${formatLatex(currentResult.perturbedX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ f(${perturbedXLatex}) &=& ${formatLatex(currentResult.funcResult2)}\r\n        \\\\ ${newXLatex} &=& ${previousXLatex} - \\frac{\\delta \\cdot ${previousXLatex} \\cdot f(${previousXLatex})}{f(${perturbedXLatex}) - f(${previousXLatex})}\r\n        \\\\              &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'derivative', color: Desmos.Colors.GREEN, lineStyle: Desmos.Styles.DOTTED, latex:\r\n                    `(y-${currentResult.funcResult})/(x-${currentResult.previousX})=${(currentResult.funcResult2 - currentResult.funcResult) / (params.perturbation * currentResult.previousX)}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel: true, latex:\r\n                    `(${currentResult.previousX}, ${currentResult.funcResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => setCurrentIteration(value)}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{ currentIteration, graphCallback, smallScreen, ...params }} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearSecant;","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js",["220"],"import { isValidMath, mathjsToLatex, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".derivative-input\",\r\n        title: \"Derivative\",\r\n        content:\r\n            \"The function's derivative will be shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Newton's method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearNewton({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    // Another sample would be: `3x^2+2x-8`\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue, derivValue, derivLatex;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        derivValue = derivative(functionText, 'x');\r\n        derivLatex = mathjsToLatex(derivValue);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(0.0);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX : results[i - 1].newX;\r\n            let funcResult, derivResult;\r\n            try {\r\n                funcResult = functionValue.evaluate({ x: previousX });\r\n                derivResult = derivValue.evaluate({ x: previousX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n\r\n            let newX = previousX - funcResult / derivResult;\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                funcResult,\r\n                derivResult,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, iterations, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"derivative-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Derivative:\r\n                                        </Typography>\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                        <Collapse in={!functionError}>\r\n                                            {!functionError && <Fade triggerOnce><TeX math={derivLatex} block /></Fade>}\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialX-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial value, <TeX math={String.raw`x_0`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setInitialX(parseFloat(event.target.value))}\r\n                                            error={initialXError}\r\n                                            label={initialXError ? \"Error\" : \"\"}\r\n                                            defaultValue={initialX.toString()}\r\n                                            helperText={initialXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lll}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ f'(${previousXLatex}) &=& ${formatLatex(currentResult.derivResult)}\r\n        \\\\ ${newXLatex} &=& ${previousXLatex} - \\frac{f(${previousXLatex})}{f'(${previousXLatex})}\r\n        \\\\                       &=& ${formatLatex(currentResult.newX)}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'derivative', color: Desmos.Colors.GREEN, lineStyle: Desmos.Styles.DOTTED, latex:\r\n                    `(y-${currentResult.funcResult})/(x-${currentResult.previousX})=${currentResult.derivResult}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel: true, latex:\r\n                    `(${currentResult.previousX}, ${currentResult.funcResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearNewton;","F:\\numerical-methods-js\\src\\components\\menu\\MethodType.js",["221","222","223","224","225"],"F:\\numerical-methods-js\\src\\components\\Graph.js",["226"],"import {React, useState, useRef, useEffect, useCallback } from \"react\";\r\nimport Button from '@material-ui/core/Button';\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport MuiDialogTitle from '@material-ui/core/DialogTitle';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport TimelineIcon from '@material-ui/icons/Timeline';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\nimport * as Desmos from 'desmos';\r\nimport { Fade } from \"react-awesome-reveal\";\r\n\r\nimport { withStyles } from '@material-ui/core/styles';\r\nconst styleClasses = (theme) => ({\r\n    root: {\r\n        margin: 0,\r\n        padding: theme.spacing(2),\r\n    },\r\n    closeButton: {\r\n        position: 'absolute',\r\n        right: theme.spacing(1),\r\n        top: theme.spacing(1),\r\n        color: theme.palette.grey[500],\r\n    },\r\n});\r\n\r\nconst DialogTitle = withStyles(styleClasses)((props) => {\r\n    const { children, classes, onClose, ...other } = props;\r\n    return (\r\n      <MuiDialogTitle disableTypography className={classes.root} {...other}>\r\n        {onClose ? (\r\n          <IconButton aria-label=\"close\" className={classes.closeButton} onClick={onClose}>\r\n            <CloseIcon />\r\n          </IconButton>\r\n        ) : null}\r\n      </MuiDialogTitle>\r\n    );\r\n});\r\n\r\nconst DialogContent =  withStyles((theme) => ({\r\n    root: {\r\n        padding: theme.spacing(2),\r\n    },\r\n}))((props) => {\r\n    const params = props.params;\r\n    const [currentIteration, setCurrentIteration] = useState(params.currentIteration);\r\n    const defaultIteration = params.currentIteration;\r\n    const currentResult = params.iterations > 0 ? params.results[currentIteration - 1] : null;\r\n    const desmosDiv = useRef(null);\r\n    const calculator = useRef(null);\r\n\r\n    const updateGraph = useCallback(() => {\r\n        if (calculator.current){\r\n            calculator.current.updateSettings({xAxisLabel: 'x', yAxisLabel: 'y',  xAxisArrowMode: Desmos.AxisArrowModes.POSITIVE, yAxisArrowMode: Desmos.AxisArrowModes.POSITIVE });\r\n            params.graphCallback(calculator, currentResult, currentIteration);\r\n        }\r\n    }, [calculator, currentResult, params, currentIteration]);\r\n    updateGraph();\r\n\r\n    useEffect(() => {\r\n        if (desmosDiv.current){\r\n            const smallScreen = props.smallScreen;\r\n            desmosDiv.current.style.width = smallScreen?'90vw':'60vw';\r\n            desmosDiv.current.style.height = smallScreen?'90vh':'60vh';\r\n            const desmosOptions = {\r\n                keypad: false,\r\n                expressions: false,\r\n                expressionsTopbar: false,\r\n            };\r\n            calculator.current = Desmos.GraphingCalculator(desmosDiv.current, desmosOptions);\r\n            updateGraph();\r\n        }\r\n    }, []);\r\n\r\n    return (\r\n        \r\n        <Grid container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n            {params.description && <Box component=\"div\" overflow=\"visible\">\r\n                    <Typography variant=\"h6\">\r\n                        {params.description}\r\n                    </Typography>\r\n                </Box>\r\n            }\r\n            {params.functionLatex && <Box component=\"div\" overflow=\"visible\">\r\n                    <TeX math={`${params.functionLatex}`} block />\r\n                </Box>\r\n            }\r\n            <Typography variant=\"h6\">\r\n                {params.iterations > 0 ? `Iteration ${currentIteration}:` : <br />}\r\n            </Typography>\r\n            {params.iterations > 0 &&\r\n                <Box width=\"70%\">\r\n                    <Slider\r\n                        orientation=\"horizontal\"\r\n                        onChange={(event, value) => setCurrentIteration(value)}\r\n                        defaultValue={defaultIteration}\r\n                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                        step={1}\r\n                        marks\r\n                        min={1}\r\n                        max={params.iterations}\r\n                        valueLabelDisplay=\"auto\"\r\n                    />\r\n                </Box>\r\n            }\r\n            <Grid item>\r\n                <div ref={desmosDiv}>\r\n                </div>\r\n            </Grid>\r\n        </Grid>\r\n    );\r\n});\r\n\r\nfunction Graph({params, smallScreen}) {\r\n    const [openDialog, setOpenDialog] = useState(false);\r\n\r\n    const handleClickOpen = () => {\r\n        setOpenDialog(true);\r\n    };\r\n      const handleClose = () => {\r\n        setOpenDialog(false);\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Button variant=\"contained\" color=\"primary\" endIcon={<TimelineIcon/>} onClick={handleClickOpen}>\r\n                View Graph\r\n            </Button>\r\n            \r\n            <Dialog scroll='paper' maxWidth={false} fullScreen={smallScreen} onClose={handleClose} aria-labelledby=\"customized-dialog-title\" open={openDialog}>\r\n                <Fade>\r\n                    <DialogTitle id=\"customized-dialog-title\" onClose={handleClose} />\r\n                    <DialogContent dividers smallScreen={smallScreen} params={params} />\r\n                </Fade>\r\n            </Dialog>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Graph;","F:\\numerical-methods-js\\src\\components\\matrix_utils.js",[],"F:\\numerical-methods-js\\src\\components\\MethodInfo.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\mainPage.js",[],"F:\\numerical-methods-js\\src\\components\\allMethods\\Bisection.js",["227","228","229","230","231","232","233"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Finite.js",["234","235","236","237","238","239"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Secant.js",["240","241","242","243","244"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Newton.js",["245","246","247","248","249","250","251"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Simpson.js",["252","253","254","255","256","257","258","259"],"F:\\numerical-methods-js\\src\\components\\allMethods\\JacobiSeidel.js",["260","261","262","263","264","265","266"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Trapezoidal.js",["267","268","269","270","271","272","273","274"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Euler.js",["275","276","277","278","279","280","281"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Taylor.js",["282","283","284","285","286","287","288"],"F:\\numerical-methods-js\\src\\components\\allMethods\\Runge.js",["289","290","291","292","293","294","295"],{"ruleId":"296","replacedBy":"297"},{"ruleId":"298","replacedBy":"299"},{"ruleId":"300","severity":1,"message":"301","line":1,"column":8,"nodeType":"302","messageId":"303","endLine":1,"endColumn":14},{"ruleId":"300","severity":1,"message":"304","line":8,"column":8,"nodeType":"302","messageId":"303","endLine":8,"endColumn":18},{"ruleId":"300","severity":1,"message":"305","line":10,"column":8,"nodeType":"302","messageId":"303","endLine":10,"endColumn":11},{"ruleId":"300","severity":1,"message":"306","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":11},{"ruleId":"300","severity":1,"message":"307","line":7,"column":8,"nodeType":"302","messageId":"303","endLine":7,"endColumn":20},{"ruleId":"300","severity":1,"message":"308","line":8,"column":8,"nodeType":"302","messageId":"303","endLine":8,"endColumn":20},{"ruleId":"300","severity":1,"message":"309","line":10,"column":8,"nodeType":"302","messageId":"303","endLine":10,"endColumn":23},{"ruleId":"300","severity":1,"message":"310","line":11,"column":8,"nodeType":"302","messageId":"303","endLine":11,"endColumn":18},{"ruleId":"300","severity":1,"message":"311","line":12,"column":8,"nodeType":"302","messageId":"303","endLine":12,"endColumn":18},{"ruleId":"300","severity":1,"message":"312","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":24,"column":8,"nodeType":"302","messageId":"303","endLine":24,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":25,"column":8,"nodeType":"302","messageId":"303","endLine":25,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":118,"column":21,"nodeType":"318","messageId":"319","endLine":118,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":239,"column":11,"nodeType":"302","messageId":"303","endLine":239,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":476,"column":9,"nodeType":"302","messageId":"303","endLine":476,"endColumn":22},{"ruleId":"300","severity":1,"message":"301","line":1,"column":8,"nodeType":"302","messageId":"303","endLine":1,"endColumn":14},{"ruleId":"300","severity":1,"message":"322","line":2,"column":10,"nodeType":"302","messageId":"303","endLine":2,"endColumn":22},{"ruleId":"300","severity":1,"message":"323","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":18},{"ruleId":"300","severity":1,"message":"306","line":11,"column":8,"nodeType":"302","messageId":"303","endLine":11,"endColumn":11},{"ruleId":"300","severity":1,"message":"324","line":15,"column":8,"nodeType":"302","messageId":"303","endLine":15,"endColumn":14},{"ruleId":"300","severity":1,"message":"313","line":19,"column":8,"nodeType":"302","messageId":"303","endLine":19,"endColumn":15},{"ruleId":"300","severity":1,"message":"325","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":16},{"ruleId":"300","severity":1,"message":"326","line":26,"column":10,"nodeType":"302","messageId":"303","endLine":26,"endColumn":14},{"ruleId":"300","severity":1,"message":"327","line":84,"column":7,"nodeType":"302","messageId":"303","endLine":84,"endColumn":17},{"ruleId":"300","severity":1,"message":"328","line":87,"column":7,"nodeType":"302","messageId":"303","endLine":87,"endColumn":18},{"ruleId":"300","severity":1,"message":"329","line":101,"column":7,"nodeType":"302","messageId":"303","endLine":101,"endColumn":20},{"ruleId":"300","severity":1,"message":"330","line":108,"column":10,"nodeType":"302","messageId":"303","endLine":108,"endColumn":22},{"ruleId":"300","severity":1,"message":"331","line":122,"column":7,"nodeType":"302","messageId":"303","endLine":122,"endColumn":20},{"ruleId":"316","severity":1,"message":"317","line":128,"column":21,"nodeType":"318","messageId":"319","endLine":128,"endColumn":42},{"ruleId":"300","severity":1,"message":"312","line":5,"column":8,"nodeType":"302","messageId":"303","endLine":5,"endColumn":13},{"ruleId":"316","severity":1,"message":"317","line":134,"column":21,"nodeType":"318","messageId":"319","endLine":134,"endColumn":42},{"ruleId":"300","severity":1,"message":"321","line":455,"column":9,"nodeType":"302","messageId":"303","endLine":455,"endColumn":22},{"ruleId":"300","severity":1,"message":"312","line":5,"column":8,"nodeType":"302","messageId":"303","endLine":5,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":26,"column":8,"nodeType":"302","messageId":"303","endLine":26,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":27,"column":8,"nodeType":"302","messageId":"303","endLine":27,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":28,"column":8,"nodeType":"302","messageId":"303","endLine":28,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":134,"column":21,"nodeType":"318","messageId":"319","endLine":134,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":208,"column":11,"nodeType":"302","messageId":"303","endLine":208,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":416,"column":9,"nodeType":"302","messageId":"303","endLine":416,"endColumn":22},{"ruleId":"316","severity":1,"message":"317","line":116,"column":21,"nodeType":"318","messageId":"319","endLine":116,"endColumn":42},{"ruleId":"316","severity":1,"message":"317","line":116,"column":21,"nodeType":"318","messageId":"319","endLine":116,"endColumn":42},{"ruleId":"300","severity":1,"message":"332","line":3,"column":37,"nodeType":"302","messageId":"303","endLine":3,"endColumn":44},{"ruleId":"316","severity":1,"message":"317","line":112,"column":21,"nodeType":"318","messageId":"319","endLine":112,"endColumn":42},{"ruleId":"300","severity":1,"message":"313","line":8,"column":8,"nodeType":"302","messageId":"303","endLine":8,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":9,"column":8,"nodeType":"302","messageId":"303","endLine":9,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":10,"column":8,"nodeType":"302","messageId":"303","endLine":10,"endColumn":16},{"ruleId":"300","severity":1,"message":"333","line":82,"column":11,"nodeType":"302","messageId":"303","endLine":82,"endColumn":22},{"ruleId":"300","severity":1,"message":"320","line":86,"column":11,"nodeType":"302","messageId":"303","endLine":86,"endColumn":19},{"ruleId":"296","replacedBy":"334"},{"ruleId":"298","replacedBy":"335"},{"ruleId":"300","severity":1,"message":"326","line":12,"column":8,"nodeType":"302","messageId":"303","endLine":12,"endColumn":12},{"ruleId":"336","severity":1,"message":"337","line":238,"column":57,"nodeType":"338","messageId":"339","endLine":238,"endColumn":83},{"ruleId":"336","severity":1,"message":"340","line":242,"column":53,"nodeType":"338","messageId":"339","endLine":242,"endColumn":79},{"ruleId":"316","severity":1,"message":"317","line":136,"column":21,"nodeType":"318","messageId":"319","endLine":136,"endColumn":42},{"ruleId":"316","severity":1,"message":"317","line":139,"column":21,"nodeType":"318","messageId":"319","endLine":139,"endColumn":42},{"ruleId":"300","severity":1,"message":"307","line":6,"column":8,"nodeType":"302","messageId":"303","endLine":6,"endColumn":20},{"ruleId":"300","severity":1,"message":"341","line":8,"column":10,"nodeType":"302","messageId":"303","endLine":8,"endColumn":15},{"ruleId":"300","severity":1,"message":"342","line":8,"column":17,"nodeType":"302","messageId":"303","endLine":8,"endColumn":20},{"ruleId":"300","severity":1,"message":"343","line":9,"column":8,"nodeType":"302","messageId":"303","endLine":9,"endColumn":38},{"ruleId":"300","severity":1,"message":"344","line":10,"column":8,"nodeType":"302","messageId":"303","endLine":10,"endColumn":26},{"ruleId":"345","severity":1,"message":"346","line":77,"column":8,"nodeType":"347","endLine":77,"endColumn":10,"suggestions":"348"},{"ruleId":"300","severity":1,"message":"312","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":24,"column":8,"nodeType":"302","messageId":"303","endLine":24,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":25,"column":8,"nodeType":"302","messageId":"303","endLine":25,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":118,"column":21,"nodeType":"318","messageId":"319","endLine":118,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":239,"column":11,"nodeType":"302","messageId":"303","endLine":239,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":476,"column":9,"nodeType":"302","messageId":"303","endLine":476,"endColumn":22},{"ruleId":"300","severity":1,"message":"332","line":3,"column":38,"nodeType":"302","messageId":"303","endLine":3,"endColumn":45},{"ruleId":"300","severity":1,"message":"313","line":20,"column":8,"nodeType":"302","messageId":"303","endLine":20,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":21,"column":8,"nodeType":"302","messageId":"303","endLine":21,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":22,"column":8,"nodeType":"302","messageId":"303","endLine":22,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":112,"column":21,"nodeType":"318","messageId":"319","endLine":112,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":290,"column":11,"nodeType":"302","messageId":"303","endLine":290,"endColumn":19},{"ruleId":"300","severity":1,"message":"313","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":24,"column":8,"nodeType":"302","messageId":"303","endLine":24,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":25,"column":8,"nodeType":"302","messageId":"303","endLine":25,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":136,"column":21,"nodeType":"318","messageId":"319","endLine":136,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":211,"column":11,"nodeType":"302","messageId":"303","endLine":211,"endColumn":19},{"ruleId":"300","severity":1,"message":"312","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":24,"column":8,"nodeType":"302","messageId":"303","endLine":24,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":25,"column":8,"nodeType":"302","messageId":"303","endLine":25,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":139,"column":21,"nodeType":"318","messageId":"319","endLine":139,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":203,"column":11,"nodeType":"302","messageId":"303","endLine":203,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":364,"column":9,"nodeType":"302","messageId":"303","endLine":364,"endColumn":22},{"ruleId":"300","severity":1,"message":"312","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":21,"column":8,"nodeType":"302","messageId":"303","endLine":21,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":22,"column":8,"nodeType":"302","messageId":"303","endLine":22,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":16},{"ruleId":"300","severity":1,"message":"333","line":103,"column":11,"nodeType":"302","messageId":"303","endLine":103,"endColumn":22},{"ruleId":"316","severity":1,"message":"317","line":116,"column":21,"nodeType":"318","messageId":"319","endLine":116,"endColumn":42},{"ruleId":"300","severity":1,"message":"321","line":232,"column":9,"nodeType":"302","messageId":"303","endLine":232,"endColumn":22},{"ruleId":"300","severity":1,"message":"320","line":254,"column":11,"nodeType":"302","messageId":"303","endLine":254,"endColumn":19},{"ruleId":"300","severity":1,"message":"326","line":14,"column":8,"nodeType":"302","messageId":"303","endLine":14,"endColumn":12},{"ruleId":"300","severity":1,"message":"313","line":31,"column":8,"nodeType":"302","messageId":"303","endLine":31,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":32,"column":8,"nodeType":"302","messageId":"303","endLine":32,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":33,"column":8,"nodeType":"302","messageId":"303","endLine":33,"endColumn":16},{"ruleId":"336","severity":1,"message":"337","line":240,"column":57,"nodeType":"338","messageId":"339","endLine":240,"endColumn":83},{"ruleId":"336","severity":1,"message":"340","line":244,"column":53,"nodeType":"338","messageId":"339","endLine":244,"endColumn":79},{"ruleId":"300","severity":1,"message":"320","line":332,"column":11,"nodeType":"302","messageId":"303","endLine":332,"endColumn":19},{"ruleId":"300","severity":1,"message":"312","line":4,"column":8,"nodeType":"302","messageId":"303","endLine":4,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":21,"column":8,"nodeType":"302","messageId":"303","endLine":21,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":22,"column":8,"nodeType":"302","messageId":"303","endLine":22,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":23,"column":8,"nodeType":"302","messageId":"303","endLine":23,"endColumn":16},{"ruleId":"300","severity":1,"message":"333","line":103,"column":11,"nodeType":"302","messageId":"303","endLine":103,"endColumn":22},{"ruleId":"316","severity":1,"message":"317","line":116,"column":21,"nodeType":"318","messageId":"319","endLine":116,"endColumn":42},{"ruleId":"300","severity":1,"message":"321","line":213,"column":9,"nodeType":"302","messageId":"303","endLine":213,"endColumn":22},{"ruleId":"300","severity":1,"message":"320","line":240,"column":11,"nodeType":"302","messageId":"303","endLine":240,"endColumn":19},{"ruleId":"300","severity":1,"message":"312","line":5,"column":8,"nodeType":"302","messageId":"303","endLine":5,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":26,"column":8,"nodeType":"302","messageId":"303","endLine":26,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":27,"column":8,"nodeType":"302","messageId":"303","endLine":27,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":28,"column":8,"nodeType":"302","messageId":"303","endLine":28,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":134,"column":21,"nodeType":"318","messageId":"319","endLine":134,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":208,"column":11,"nodeType":"302","messageId":"303","endLine":208,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":416,"column":9,"nodeType":"302","messageId":"303","endLine":416,"endColumn":22},{"ruleId":"300","severity":1,"message":"312","line":5,"column":8,"nodeType":"302","messageId":"303","endLine":5,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":24,"column":8,"nodeType":"302","messageId":"303","endLine":24,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":25,"column":8,"nodeType":"302","messageId":"303","endLine":25,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":26,"column":8,"nodeType":"302","messageId":"303","endLine":26,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":134,"column":21,"nodeType":"318","messageId":"319","endLine":134,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":229,"column":11,"nodeType":"302","messageId":"303","endLine":229,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":451,"column":9,"nodeType":"302","messageId":"303","endLine":451,"endColumn":22},{"ruleId":"300","severity":1,"message":"312","line":5,"column":8,"nodeType":"302","messageId":"303","endLine":5,"endColumn":13},{"ruleId":"300","severity":1,"message":"313","line":24,"column":8,"nodeType":"302","messageId":"303","endLine":24,"endColumn":15},{"ruleId":"300","severity":1,"message":"314","line":25,"column":8,"nodeType":"302","messageId":"303","endLine":25,"endColumn":11},{"ruleId":"300","severity":1,"message":"315","line":26,"column":8,"nodeType":"302","messageId":"303","endLine":26,"endColumn":16},{"ruleId":"316","severity":1,"message":"317","line":128,"column":21,"nodeType":"318","messageId":"319","endLine":128,"endColumn":42},{"ruleId":"300","severity":1,"message":"320","line":201,"column":11,"nodeType":"302","messageId":"303","endLine":201,"endColumn":19},{"ruleId":"300","severity":1,"message":"321","line":393,"column":9,"nodeType":"302","messageId":"303","endLine":393,"endColumn":22},"no-native-reassign",["349"],"no-negated-in-lhs",["350"],"no-unused-vars","'styles' is defined but never used.","Identifier","unusedVar","'Typography' is defined but never used.","'TeX' is defined but never used.","'Box' is defined but never used.","'ListItemIcon' is defined but never used.","'ListItemText' is defined but never used.","'DoubleArrowIcon' is defined but never used.","'ExpandLess' is defined but never used.","'ExpandMore' is defined but never used.","'Graph' is defined but never used.","'Tooltip' is defined but never used.","'Fab' is defined but never used.","'HelpIcon' is defined but never used.","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'openHelp' is assigned a value but never used.","'graphCallback' is assigned a value but never used.","'generatePath' is defined but never used.","'MethodInfo' is defined but never used.","'Dialog' is defined but never used.","'HomeIcon' is defined but never used.","'Link' is defined but never used.","'Transition' is assigned a value but never used.","'DialogTitle' is assigned a value but never used.","'DialogContent' is assigned a value but never used.","'HideOnScroll' is defined but never used.","'searchOptions' is assigned a value but never used.","'useMemo' is defined but never used.","'smallScreen' is assigned a value but never used.",["349"],["350"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'modifiedMatrix'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'modifiedOutput'.","'green' is defined but never used.","'red' is defined but never used.","'CheckCircleOutlineOutlinedIcon' is defined but never used.","'CancelOutlinedIcon' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'props.smallScreen' and 'updateGraph'. Either include them or remove the dependency array.","ArrayExpression",["351"],"no-global-assign","no-unsafe-negation",{"desc":"352","fix":"353"},"Update the dependencies array to be: [props.smallScreen, updateGraph]",{"range":"354","text":"355"},[2998,3000],"[props.smallScreen, updateGraph]"]
[{"F:\\numerical-methods-js\\src\\index.js":"1","F:\\numerical-methods-js\\src\\reportWebVitals.js":"2","F:\\numerical-methods-js\\src\\App.js":"3","F:\\numerical-methods-js\\src\\components\\utils.js":"4","F:\\numerical-methods-js\\src\\components\\NotFound.js":"5","F:\\numerical-methods-js\\src\\components\\ErrorBoundary.js":"6","F:\\numerical-methods-js\\src\\components\\menu\\Menu.js":"7","F:\\numerical-methods-js\\src\\constants\\categories.js":"8","F:\\numerical-methods-js\\src\\components\\menu\\Category.js":"9","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js":"10","F:\\numerical-methods-js\\src\\components\\header\\Header.js":"11","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FalsePosition.js":"12","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Shooting.js":"13","F:\\numerical-methods-js\\src\\components\\methods\\ode\\FiniteDiff.js":"14","F:\\numerical-methods-js\\src\\components\\methods\\ode\\System.js":"15","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js":"16","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Multistep.js":"17","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js":"18","F:\\numerical-methods-js\\src\\components\\methods\\integral\\MonteCarlo.js":"19","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js":"20","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js":"21","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Quadrature.js":"22","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js":"23","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Midpoint.js":"24","F:\\numerical-methods-js\\src\\components\\methods\\differential\\Multivariable.js":"25","F:\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js":"26","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\Discs.js":"27","F:\\numerical-methods-js\\src\\components\\methods\\optimisation\\Gradient.js":"28","F:\\numerical-methods-js\\src\\components\\methods\\optimisation\\GoldenSearch.js":"29","F:\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js":"30","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js":"31","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\Power.js":"32","F:\\numerical-methods-js\\src\\components\\methods\\linear\\PenroseInverse.js":"33","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\InversePower.js":"34","F:\\numerical-methods-js\\src\\components\\methods\\linear\\Inverse.js":"35","F:\\numerical-methods-js\\src\\components\\methods\\linear\\SVD.js":"36","F:\\numerical-methods-js\\src\\components\\methods\\linear\\LU.js":"37","F:\\numerical-methods-js\\src\\components\\methods\\linear\\QR.js":"38","F:\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js":"39","F:\\numerical-methods-js\\src\\components\\methods\\linear\\Gauss.js":"40","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FixedPoint.js":"41","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Secant.js":"42","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js":"43","F:\\numerical-methods-js\\src\\components\\menu\\MethodType.js":"44","F:\\numerical-methods-js\\src\\components\\Graph.js":"45","F:\\numerical-methods-js\\src\\components\\matrix_utils.js":"46","F:\\numerical-methods-js\\src\\components\\MethodInfo.js":"47","F:\\numerical-methods-js\\src\\components\\methods\\test.js":"48"},{"size":1039,"mtime":1652551373134,"results":"49","hashOfConfig":"50"},{"size":375,"mtime":1652546807575,"results":"51","hashOfConfig":"50"},{"size":1660,"mtime":1652550478085,"results":"52","hashOfConfig":"50"},{"size":1896,"mtime":1652546807572,"results":"53","hashOfConfig":"50"},{"size":1927,"mtime":1652546807543,"results":"54","hashOfConfig":"50"},{"size":2419,"mtime":1652546807542,"results":"55","hashOfConfig":"50"},{"size":2441,"mtime":1652546807545,"results":"56","hashOfConfig":"50"},{"size":8644,"mtime":1652550754652,"results":"57","hashOfConfig":"50"},{"size":1516,"mtime":1652546807545,"results":"58","hashOfConfig":"50"},{"size":23742,"mtime":1652551486974,"results":"59","hashOfConfig":"50"},{"size":6136,"mtime":1652550938114,"results":"60","hashOfConfig":"50"},{"size":24045,"mtime":1652551513682,"results":"61","hashOfConfig":"50"},{"size":32791,"mtime":1652551513834,"results":"62","hashOfConfig":"50"},{"size":23675,"mtime":1652551514375,"results":"63","hashOfConfig":"50"},{"size":35179,"mtime":1652551513836,"results":"64","hashOfConfig":"50"},{"size":20952,"mtime":1652551513782,"results":"65","hashOfConfig":"50"},{"size":25774,"mtime":1652551513684,"results":"66","hashOfConfig":"50"},{"size":23465,"mtime":1652551513974,"results":"67","hashOfConfig":"50"},{"size":19243,"mtime":1652551513265,"results":"68","hashOfConfig":"50"},{"size":22153,"mtime":1652551320510,"results":"69","hashOfConfig":"50"},{"size":18736,"mtime":1652551513280,"results":"70","hashOfConfig":"50"},{"size":17210,"mtime":1652551515393,"results":"71","hashOfConfig":"50"},{"size":17414,"mtime":1652551513682,"results":"72","hashOfConfig":"50"},{"size":17356,"mtime":1652551511868,"results":"73","hashOfConfig":"50"},{"size":3710,"mtime":1652551515389,"results":"74","hashOfConfig":"50"},{"size":18421,"mtime":1652551515389,"results":"75","hashOfConfig":"50"},{"size":13529,"mtime":1652551511815,"results":"76","hashOfConfig":"50"},{"size":27220,"mtime":1652551514378,"results":"77","hashOfConfig":"50"},{"size":22785,"mtime":1652551513974,"results":"78","hashOfConfig":"50"},{"size":3682,"mtime":1652551511780,"results":"79","hashOfConfig":"50"},{"size":25570,"mtime":1652551513974,"results":"80","hashOfConfig":"50"},{"size":21772,"mtime":1652551513974,"results":"81","hashOfConfig":"50"},{"size":18342,"mtime":1652551515158,"results":"82","hashOfConfig":"50"},{"size":23263,"mtime":1652551514088,"results":"83","hashOfConfig":"50"},{"size":16578,"mtime":1652551515369,"results":"84","hashOfConfig":"50"},{"size":17178,"mtime":1652551515157,"results":"85","hashOfConfig":"50"},{"size":19710,"mtime":1652551515158,"results":"86","hashOfConfig":"50"},{"size":18384,"mtime":1652551514393,"results":"87","hashOfConfig":"50"},{"size":35756,"mtime":1652551515204,"results":"88","hashOfConfig":"50"},{"size":23832,"mtime":1652551515205,"results":"89","hashOfConfig":"50"},{"size":16408,"mtime":1652551513682,"results":"90","hashOfConfig":"50"},{"size":19263,"mtime":1652551514380,"results":"91","hashOfConfig":"50"},{"size":17799,"mtime":1652551513683,"results":"92","hashOfConfig":"50"},{"size":1642,"mtime":1652546807546,"results":"93","hashOfConfig":"50"},{"size":5367,"mtime":1652546807542,"results":"94","hashOfConfig":"50"},{"size":17495,"mtime":1652546807544,"results":"95","hashOfConfig":"50"},{"size":1278,"mtime":1652546807543,"results":"96","hashOfConfig":"50"},{"size":121,"mtime":1652549821769,"results":"97","hashOfConfig":"50"},{"filePath":"98","messages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"pufcpd",{"filePath":"100","messages":"101","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"102","messages":"103","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"104","messages":"105","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"106","messages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"108","messages":"109","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"110","messages":"111","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"112","messages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":44,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"114","messages":"115","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"116","messages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"118","messages":"119","errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"120","messages":"121","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"122","usedDeprecatedRules":"123"},{"filePath":"124","messages":"125","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"126","usedDeprecatedRules":"123"},{"filePath":"127","messages":"128","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"129"},{"filePath":"130","messages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"132","usedDeprecatedRules":"123"},{"filePath":"133","messages":"134","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"135","usedDeprecatedRules":"123"},{"filePath":"136","messages":"137","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"138","usedDeprecatedRules":"123"},{"filePath":"139","messages":"140","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"141"},{"filePath":"142","messages":"143","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"144","usedDeprecatedRules":"123"},{"filePath":"145","messages":"146","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"147","usedDeprecatedRules":"123"},{"filePath":"148","messages":"149","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"150","usedDeprecatedRules":"123"},{"filePath":"151","messages":"152","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"153"},{"filePath":"154","messages":"155","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"156","usedDeprecatedRules":"123"},{"filePath":"157","messages":"158","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"159","messages":"160","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"161"},{"filePath":"162","messages":"163","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"164"},{"filePath":"165","messages":"166","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"167","messages":"168","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"169"},{"filePath":"170","messages":"171","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"172"},{"filePath":"173","messages":"174","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"175","messages":"176","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"177","messages":"178","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"179","messages":"180","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"181"},{"filePath":"182","messages":"183","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"184","messages":"185","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"186"},{"filePath":"187","messages":"188","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"189","messages":"190","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"191","messages":"192","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"193","messages":"194","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"195"},{"filePath":"196","messages":"197","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"198","messages":"199","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"200","usedDeprecatedRules":"123"},{"filePath":"201","messages":"202","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"203"},{"filePath":"204","messages":"205","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"206","usedDeprecatedRules":"123"},{"filePath":"207","messages":"208","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"209","messages":"210","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"211","messages":"212","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"213","messages":"214","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"215","messages":"216","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"F:\\numerical-methods-js\\src\\index.js",[],"F:\\numerical-methods-js\\src\\reportWebVitals.js",[],"F:\\numerical-methods-js\\src\\App.js",[],"F:\\numerical-methods-js\\src\\components\\utils.js",[],"F:\\numerical-methods-js\\src\\components\\NotFound.js",[],"F:\\numerical-methods-js\\src\\components\\ErrorBoundary.js",[],"F:\\numerical-methods-js\\src\\components\\menu\\Menu.js",[],"F:\\numerical-methods-js\\src\\constants\\categories.js",["217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260"],"F:\\numerical-methods-js\\src\\components\\menu\\Category.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Bisection.js",["261","262","263","264","265","266","267"],"F:\\numerical-methods-js\\src\\components\\header\\Header.js",["268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285"],"F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FalsePosition.js",["286"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearFalsePosition({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(0);\r\n    const [upperX, setUpperX] = useState(3);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be a number!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"Upper x must be a number!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.0005);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    else if (errorThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || thresholdError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    let results = [];\r\n    let iterations = 1;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let i = 0;\r\n        while (true) {\r\n            let oldLowerX = (i === 0) ? lowerX : results[i - 1].newLowerX;\r\n            let oldUpperX = (i === 0) ? upperX : results[i - 1].newUpperX;\r\n            let newLowerX = oldLowerX;\r\n            let newUpperX = oldUpperX;\r\n            let lowerFuncResult, upperFuncResult, rootX, rootFuncResult, errorX;\r\n            try {\r\n                lowerFuncResult = functionValue.evaluate({ x: oldLowerX });\r\n                upperFuncResult = functionValue.evaluate({ x: oldUpperX }); // upperFuncResult is for visualisation purposes, no relevance in the calculations\r\n                rootX = oldUpperX - upperFuncResult * (oldLowerX - oldUpperX) / (lowerFuncResult - upperFuncResult);\r\n                rootFuncResult = functionValue.evaluate({ x: rootX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            let rootFound = false;\r\n            let product = lowerFuncResult * rootFuncResult;\r\n            if (product < 0) {\r\n                newUpperX = rootX;\r\n            }\r\n            else if (product > 0) {\r\n                newLowerX = rootX;\r\n            }\r\n            else {\r\n                rootFound = true;\r\n            }\r\n\r\n            if (!rootFound && i !== 0) {\r\n                // Check if root error is lower than threshold\r\n                errorX = Math.abs(rootX - results[i - 1].rootX);\r\n                if (errorX < errorThreshold) {\r\n                    rootFound = true;\r\n                }\r\n            }\r\n            results.push({\r\n                oldLowerX,\r\n                newLowerX,\r\n                oldUpperX,\r\n                newUpperX,\r\n                rootX,\r\n                lowerFuncResult,\r\n                upperFuncResult,\r\n                rootFuncResult,\r\n                errorX,\r\n            });\r\n            i++;\r\n            if (rootFound) {\r\n                break;\r\n            }\r\n            if (i > 1000) {\r\n                exceedIterError = true;\r\n                exceedIterErrorText = \"Exceeded 1000 iterations!\";\r\n                break;\r\n            }\r\n        }\r\n        iterations = i;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, errorThreshold, iterations, exceedIterError, exceedIterErrorText, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, f(x):\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"errorThreshold-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Error threshold:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setErrorThreshold(parseFloat(event.target.value))}\r\n                                            error={thresholdError}\r\n                                            label={thresholdError ? \"Error\" : \"\"}\r\n                                            defaultValue={errorThreshold.toString()}\r\n                                            helperText={thresholdErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n\r\n        </>\r\n    );\r\n}\r\n/*\r\nimport Snackbar from '@material-ui/core/Snackbar';\r\nconst [openErrorSnackbar, setOpenErrorSnackbar] = useState(false);\r\nconst errorSnackbarClose = (event, reason) => {\r\n    if (reason === 'clickaway') {\r\n        return;\r\n    }\r\n    setOpenErrorSnackbar(false);\r\n};\r\n<Snackbar open={openErrorSnackbar} autoHideDuration={2000} onClose={errorSnackbarClose}>\r\n    <Alert onClose={errorSnackbarClose} severity=\"error\">\r\n        There is an error with the {functionError?\"function\":\"iterations\"}.\r\n    </Alert>\r\n</Snackbar>\r\n*/\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let oldLowerXLatex = String.raw`x_{lower_{${currentIteration - 1}}}`;\r\n        let oldUpperXLatex = String.raw`x_{upper_{${currentIteration - 1}}}`;\r\n        let newLowerXLatex = String.raw`x_{lower_{${currentIteration}}}`;\r\n        let newUpperXLatex = String.raw`x_{upper_{${currentIteration}}}`;\r\n        let newRootXLatex = String.raw`x_{root_{${currentIteration - 1}}}`;\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${oldLowerXLatex} &=& ${formatLatex(currentResult.oldLowerX)}\r\n        \\\\ ${oldUpperXLatex} &=& ${formatLatex(currentResult.oldUpperX)}\r\n        \\\\ ${newRootXLatex} &=&  ${oldUpperXLatex}-\\frac{f(${oldUpperXLatex})(${oldLowerXLatex} - ${oldUpperXLatex})}{f(${oldLowerXLatex}) - f(${oldUpperXLatex})}\r\n        \\\\                       &=& ${formatLatex(currentResult.rootX)}\r\n        \\\\\r\n        `;\r\n\r\n        let rootFound = false;\r\n        latexContent += String.raw`\r\n        \\\\ f(${oldLowerXLatex}) &=& ${formatLatex(currentResult.lowerFuncResult)}\r\n        \\\\ f(${newRootXLatex}) &=& ${formatLatex(currentResult.rootFuncResult)}\r\n        \\\\\r\n        \\\\\r\n        `;\r\n        let product = currentResult.lowerFuncResult * currentResult.rootFuncResult;\r\n        if (product < 0) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(${oldLowerXLatex})f(${newRootXLatex}) < 0,\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& ${oldLowerXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& ${newRootXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else if (product > 0) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(${oldLowerXLatex})f(${newRootXLatex}) > 0,\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& ${newRootXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& ${oldUpperXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else {\r\n            rootFound = true;\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Root found because }\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ f(${oldLowerXLatex})f(${newRootXLatex}) == 0.\r\n            `;\r\n        }\r\n\r\n        if (!rootFound && currentIteration > 1) {\r\n            let oldRootXLatex = String.raw`x_{root_{${currentIteration - 2}}}`;\r\n            latexContent += String.raw`\r\n            \\\\ ${oldRootXLatex} &=& ${formatLatex(results[currentIteration - 2].rootX)}\r\n            \\\\ Error &=& |${newRootXLatex} - ${oldRootXLatex}|\r\n            \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n            \\\\\r\n            `;\r\n            if (currentResult.errorX < params.errorThreshold) {\r\n                latexContent += String.raw`\r\n                \\end{array}\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text{Root found because:}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ Error &<& Error Threshold\r\n                \\\\ ${formatLatex(currentResult.errorX)} &<& ${formatLatex(params.errorThreshold)}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'lowerX', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"Lower\", showLabel: true, latex:\r\n                    `(${currentResult.oldLowerX}, ${currentResult.lowerFuncResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'upperX', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"Upper\", showLabel: true, latex:\r\n                    `(${currentResult.oldUpperX}, ${currentResult.upperFuncResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.rootX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n\r\n                    <Grid container xs item direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                        <Grid xs item className=\"iteration-slider\">\r\n                            <Slide direction=\"left\" triggerOnce>\r\n                                <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                    <Slider\r\n                                        orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                        onChange={(event, value) => setCurrentIteration(value)}\r\n                                        defaultValue={1}\r\n                                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                                        step={1}\r\n                                        marks\r\n                                        min={1}\r\n                                        max={params.iterations}\r\n                                        valueLabelDisplay=\"on\"\r\n                                    />\r\n\r\n                                </Box>\r\n                            </Slide>\r\n                        </Grid>\r\n                        <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"step-math\">\r\n                                <Zoom duration={500} triggerOnce>\r\n                                    <Card className={styleClasses.card}>\r\n                                        <CardContent className={styleClasses.cardContent}>\r\n                                            <Typography variant=\"h6\">\r\n                                                Iteration {currentIteration}:\r\n                                            </Typography>\r\n                                            <TeX math={latexContent} block />\r\n                                        </CardContent>\r\n                                    </Card>\r\n                                </Zoom>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"graph-button\">\r\n\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearFalsePosition;",["287","288"],"F:\\numerical-methods-js\\src\\components\\methods\\ode\\Shooting.js",["289"],"import { isValidMath, mathjsToLatex, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix21 as initialMatrix, generateGridCallback, gridTo2DArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect, useRef } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, simplify } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst FUNCTIONS = ['0', '4', '-4 x'];\r\nconst FUNCTIONS_TEXT = ['0', '4', '-4 x'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n            \"Choose either Euler or Runge-Kutta.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of a, b, f(a) and f(b).\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the selected method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeShooting({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Solver mode: Euler or Runge\r\n    const [solverType, setSolverType] = useState('runge');\r\n\r\n    // Function\r\n    const [functionLatexs, setFunctionLatexs] = useState(FUNCTIONS);\r\n    const [functionTexts, setFunctionTexts] = useState(FUNCTIONS_TEXT);\r\n\r\n    const functionLatexsRef = useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef = useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = Array(3).fill(false);\r\n    let functionErrorTexts = Array(3).fill(\"\");\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (node.name !== 'x') {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n            funcNode.evaluate({ x: 0 });\r\n        }\r\n        catch (e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    const [lowerX, upperX] = [initialVector[0], initialVector[2]];\r\n    let intervalError = false;\r\n    let intervalErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        intervalErrorText = \"a must be lower than b!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    const functionsError = !functionErrors.every((e) => e === false);\r\n    let hasError = functionsError || intervalError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let stepSize, xArray;\r\n    let f1Node, f2Node;\r\n    let results1 = { y: [], u: [] }; // First solution\r\n    let results2 = { y: [], u: [] }; // Second solution\r\n    let results = []; // Final solution\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        stepSize = (upperX - lowerX) / iterations;\r\n        xArray = [...Array(iterations).keys()].map((i) => stepSize * (i + 1));\r\n        const stepHalf = stepSize / 2;\r\n        const generateResults = (resultsArray, node, initialValues) => {\r\n            for (let iter = 0; iter < iterations; iter++) {\r\n                // Get current values\r\n                const currentX = (iter === 0) ? initialVector[0] : xArray[iter - 1];\r\n                const currentY = (iter === 0) ? initialValues[0] : resultsArray.y[iter - 1].newValue;\r\n                const currentU = (iter === 0) ? initialValues[1] : resultsArray.u[iter - 1].newValue;\r\n\r\n                // Find new values\r\n                if (solverType === 'runge') {\r\n                    // k1\r\n                    const k1Y = currentU;\r\n                    const k1U = node.evaluate({ x: currentX, 'y': currentY, 'u': currentU });\r\n\r\n                    // k2\r\n                    const k2Y = currentU + k1U * stepHalf;\r\n                    const k2U = node.evaluate({ x: currentX + stepHalf, 'y': currentY + k1Y * stepHalf, 'u': currentU + k1U * stepHalf });\r\n\r\n                    // k3\r\n                    const k3Y = currentU + k2U * stepHalf;\r\n                    const k3U = node.evaluate({ x: currentX + stepHalf, 'y': currentY + k2Y * stepHalf, 'u': currentU + k2U * stepHalf });\r\n\r\n                    // k4\r\n                    const k4Y = currentU + k3U * stepSize;\r\n                    const k4U = node.evaluate({ x: currentX + stepSize, 'y': currentY + k3Y * stepSize, 'u': currentU + k3U * stepSize });\r\n\r\n                    const newY = currentY + stepSize / 6 * (k1Y + 2 * k2Y + 2 * k3Y + k4Y);\r\n                    const newU = currentU + stepSize / 6 * (k1U + 2 * k2U + 2 * k3U + k4U);\r\n                    resultsArray.y.push({ currentValue: currentY, newValue: newY, k1: k1Y, k2: k2Y, k3: k3Y, k4: k4Y });\r\n                    resultsArray.u.push({ currentValue: currentU, newValue: newU, k1: k1U, k2: k2U, k3: k3U, k4: k4U });\r\n                }\r\n                else {\r\n                    const uResult = node.evaluate({ x: currentX, 'y': currentY, 'u': currentU });\r\n                    const newY = currentY + stepSize * currentU;\r\n                    const newU = currentU + stepSize * uResult;\r\n                    resultsArray.y.push({ currentValue: currentY, newValue: newY, functionResult: currentU });\r\n                    resultsArray.u.push({ currentValue: currentU, newValue: newU, functionResult: uResult });\r\n                }\r\n            }\r\n        }\r\n        f1Node = simplify(parse(`(${functionTexts[0]}) u + (${functionTexts[1]}) y + (${functionTexts[2]})`));\r\n        f2Node = simplify(parse(`(${functionTexts[0]}) u + (${functionTexts[1]}) y`));\r\n        generateResults(results1, f1Node, [initialVector[1], 0]);\r\n        generateResults(results2, f2Node, [0, 1]);\r\n\r\n        // Final Y\r\n        const factor = (initialVector[3] - results1.y[iterations - 1].newValue) / results2.y[iterations - 1].newValue;\r\n        for (let i = 0; i < iterations; i++) {\r\n            results.push({\r\n                currentX: (i === 0) ? initialVector[0] : xArray[i - 1],\r\n                newX: xArray[i],\r\n                currentY: (i === 0) ? initialVector[1] : results[i - 1].newY,\r\n                newY: results1.y[i].newValue + factor * results2.y[i].newValue\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatexs, solverType, initialVector, iterations, stepSize, f1Node, f2Node, xArray, results1, results2, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`y^{''} = p(x)y^{'} + q(x)y + r(x)`} />.\r\n                        </Typography>\r\n                        <Divider />\r\n                        <Grid className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Typography variant=\"h6\">\r\n                                Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                            </Typography>\r\n                            <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event) => setSolverType(event.target.value)}>\r\n                                <FormControlLabel value=\"euler\" control={<Radio />} label=\"Euler\" />\r\n                                <FormControlLabel value=\"runge\" control={<Radio />} label=\"Runge-Kutta\" />\r\n                            </RadioGroup>\r\n                        </Grid>\r\n                        <Grid xs item className=\"functions-display\">\r\n                            <Box border={1} borderRadius={5} boxShadow={2}>\r\n                                <Collapse in={!hasError}>\r\n                                    {!functionsError && <Fade triggerOnce>\r\n                                        <TeX math={String.raw`y^{''} = (${functionLatexs[0]}) y^{'} + (${functionLatexs[1]}) y + (${functionLatexs[2]})`} block />\r\n                                    </Fade>}\r\n                                </Collapse>\r\n                            </Box>\r\n                        </Grid>\r\n                        <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={String.raw`p(x)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={FUNCTIONS[0]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(0, mathField.text());\r\n                                                setSpecificFunctionLatex(0, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[0]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[0]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={String.raw`q(x)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={FUNCTIONS[1]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(1, mathField.text());\r\n                                                setSpecificFunctionLatex(1, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[1]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[1]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={String.raw`r(x)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={FUNCTIONS[2]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(2, mathField.text());\r\n                                                setSpecificFunctionLatex(2, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[2]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[2]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                    <Collapse in={intervalError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {intervalErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    const initialVector = params.initialVector;\r\n    const xArray = params.xArray;\r\n    const currentX = (currentIteration === 1) ? initialVector[0] : xArray[currentIteration - 2];\r\n    const newX = xArray[currentIteration - 1];\r\n    const results1 = params.results1;\r\n    const results2 = params.results2;\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& ${formatLatex(params.stepSize)}\r\n        \\\\\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(newX)}\r\n        \\end{array}\r\n        \\\\\r\n        `;\r\n        const generateResultsLatex = (index, resultsArray, node, initialValues) => {\r\n            latexContent += String.raw`\r\n            \\\\ \\hline\r\n            \\\\ \\text{First we find the solution to } y_${index} \\text{ whereby}\r\n            \\\\ y^{''}_{${index}} = u^{'} = ${mathjsToLatex(node)}\r\n            \\\\ \\text{with the initial values: } y_{${index}}(${initialVector[0]}) = ${initialValues[0]} \\text{ and } y_{${index}}^{'}(${initialVector[0]}) = ${initialValues[1]}\r\n            `;\r\n            const currentYResult = resultsArray.y[currentIteration - 1];\r\n            const currentUResult = resultsArray.u[currentIteration - 1];\r\n            const currentY = (currentIteration === 1) ? initialValues[0] : resultsArray.y[currentIteration - 2].newValue;\r\n            const currentU = (currentIteration === 1) ? initialValues[1] : resultsArray.u[currentIteration - 2].newValue;\r\n            const newY = currentYResult.newValue;\r\n            const newU = currentUResult.newValue;\r\n\r\n            if (params.solverType === 'runge') {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ x_{${currentIteration - 1}} &=& ${formatLatex(currentX)}\r\n                \\\\ y_{${currentIteration - 1}} &=& ${formatLatex(currentY)}\r\n                \\\\ u_{${currentIteration - 1}} &=& ${formatLatex(currentU)}\r\n                \\\\\r\n                \\\\ k_{1y} &=& u_{${currentIteration - 1}}\r\n                \\\\        &=& ${formatLatex(currentYResult.k1)}\r\n                \\\\\r\n                \\\\ k_{1u} &=& u^{'} ( x_{${currentIteration - 1}}, y_{${currentIteration - 1}}, u_{${currentIteration - 1}} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k1)}\r\n                \\\\\r\n                \\\\ k_{2y} &=& u_{${currentIteration - 1}} + \\frac{h}{2} k_{1u}\r\n                \\\\        &=& ${formatLatex(currentYResult.k2)}\r\n                \\\\\r\n                \\\\ k_{2u} &=& u^{'} ( x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + \\frac{h}{2} k_{1y}, u_{${currentIteration - 1}} + \\frac{h}{2} k_{1u} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k2)}\r\n                \\\\\r\n                \\\\ k_{3y} &=& u_{${currentIteration - 1}} + \\frac{h}{2} k_{2u}\r\n                \\\\        &=& ${formatLatex(currentYResult.k3)}\r\n                \\\\\r\n                \\\\ k_{3u} &=& u^{'} ( x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + \\frac{h}{2} k_{2y}, u_{${currentIteration - 1}} + \\frac{h}{2} k_{2u} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k3)}\r\n                \\\\\r\n                \\\\ k_{4y} &=& u_{${currentIteration - 1}} + h k_{3u}\r\n                \\\\        &=& ${formatLatex(currentYResult.k4)}\r\n                \\\\\r\n                \\\\ k_{4u} &=& u^{'} ( x_{${currentIteration - 1}} + h, , u_{${currentIteration - 1}} + h k_{3u} )\r\n                \\\\        &=& ${formatLatex(currentUResult.k4)}\r\n                \\\\\r\n                \\\\ y^{${index}}_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1y} + 2 k_{2y} + 2 k_{3y} + k_{4y} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(newY)}\r\n                \\\\\r\n                \\\\ u^{${index}}_{${currentIteration}} &=& u_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1u} + 2 k_{2u} + 2 k_{3u} + k_{4u} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(newU)}\r\n                \\end{array}\r\n                \\\\\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ x_{${currentIteration - 1}} &=& ${formatLatex(currentX)}\r\n                \\\\ y_{${currentIteration - 1}} &=& ${formatLatex(currentY)}\r\n                \\\\ u_{${currentIteration - 1}} &=& ${formatLatex(currentU)}\r\n                \\\\\r\n                \\\\ y^{${index}}_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot u_{${currentIteration - 1}}\r\n                \\\\                                    &=& ${formatLatex(newY)}\r\n                \\\\\r\n                \\\\ u^{${index}}_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot u^{'} ( x_{${currentIteration - 1}}, y_{${currentIteration - 1}}, u_{${currentIteration - 1}} )\r\n                \\\\                                    &=& ${formatLatex(newU)}\r\n                \\end{array}\r\n                \\\\\r\n                `;\r\n            }\r\n        }\r\n        generateResultsLatex(\"A\", results1, params.f1Node, [initialVector[1], 0]);\r\n        generateResultsLatex(\"B\", results2, params.f2Node, [0, 1]);\r\n\r\n        // Final Y\r\n        latexContent += String.raw`\r\n        \\\\ \\hline\r\n        \\\\ \\text{Finally,}\r\n        \\\\ \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y^{A}_{${currentIteration}} + \\frac{y(b) - y^{A}_{${params.iterations}}}{y^{B}_{${params.iterations}}} y^{B}_{${currentIteration}}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(results1.y[currentIteration - 1].newValue)} + \\frac{${formatLatex(initialVector[3])} - ${formatLatex(results1.y[params.iterations - 1].newValue)} } {${formatLatex(results2.y[params.iterations - 1].newValue)}} ( ${formatLatex(results2.y[currentIteration - 1].newValue)} )\r\n        \\\\\r\n        \\\\                         &=& \\colorbox{aqua}{\\bf{${formatLatex(params.results[currentIteration - 1].newY)}}}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\\\ \\text{Note: } y_{${currentIteration}} \\text{ can only be computed after } y^{A} \\text{ and } y^{B} \\text{ are computed for } ${initialVector[0]} < x < ${initialVector[2]}\r\n        \\\\ \\text{in order to obtain } y^{A}_{${params.iterations}} \\text{ and }  y^{B}_{${params.iterations}}\r\n        `;\r\n\r\n        latexContent += String.raw`\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation={\"horizontal\"}\r\n                                    onChangeCommitted={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeShooting;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\FiniteDiff.js",["290"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix22 as initialMatrix, generateGridCallback, gridTo2DArray, matrixToLatex } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect, useRef } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, inv, multiply } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst FUNCTIONS = ['0', '-4', '0'];\r\nconst FUNCTIONS_TEXT = ['0', '-4', '0'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of a, b, f(a) and f(b).\",\r\n    },\r\n    {\r\n        target: \".points-input\",\r\n        title: \"Number of points\",\r\n        content:\r\n            \"Specify the number of points in between the lower and upper boundaries.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeFiniteDiff({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatexs, setFunctionLatexs] = useState(FUNCTIONS);\r\n    const [functionTexts, setFunctionTexts] = useState(FUNCTIONS_TEXT);\r\n\r\n    const functionLatexsRef = useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef = useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = Array(3).fill(false);\r\n    let functionErrorTexts = Array(3).fill(\"\");\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (node.name !== 'x') {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n            funcNode.evaluate({ x: 0 });\r\n        }\r\n        catch (e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    const [lowerX, upperX] = [initialVector[0], initialVector[2]];\r\n    let intervalError = false;\r\n    let intervalErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        intervalErrorText = \"a must be lower than b!\";\r\n    }\r\n\r\n    // Points\r\n    const [points, setPoints] = useState(9);\r\n    let pointsError = false;\r\n    let pointsErrorText = \"\";\r\n    if (!Number.isInteger(points) || points <= 0) {\r\n        pointsError = true;\r\n        pointsErrorText = \"Number of points must be a positive integer!\";\r\n    }\r\n    const iterations = points + 1;\r\n\r\n    const functionsError = !functionErrors.every((e) => e === false);\r\n    let hasError = functionsError || intervalError || pointsError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let stepSize, xArray;\r\n    let resultsMatrix = [];\r\n    let resultsColumn = [];\r\n    let resultsInverse, resultsSolved;\r\n    let results = [];\r\n    let latexContent, graphCallback;\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        stepSize = (upperX - lowerX) / iterations;\r\n        xArray = [...Array(iterations).keys()].map((i) => stepSize * (i + 1));\r\n        for (let iter = 1; iter < iterations; iter++) {\r\n            const currentX = xArray[iter - 1];\r\n            const pResult = functionNodes[0].evaluate({ x: currentX });\r\n            const qResult = functionNodes[1].evaluate({ x: currentX });\r\n            const fResult = functionNodes[2].evaluate({ x: currentX });\r\n\r\n            const previousYCoeff = (1 - stepSize / 2 * pResult);\r\n            const currentYCoeff = Math.pow(stepSize, 2) * qResult - 2;\r\n            const nextYCoeff = (1 + stepSize / 2 * pResult);\r\n            const row = Array(iterations - 1).fill(0);\r\n            row[iter - 1] = currentYCoeff;\r\n\r\n            let additionalConstant = 0;\r\n            if (iter === 1) {\r\n                additionalConstant = previousYCoeff * initialVector[1];\r\n            }\r\n            else {\r\n                row[iter - 2] = previousYCoeff;\r\n            }\r\n            if (iter === iterations - 1) {\r\n                additionalConstant = nextYCoeff * initialVector[3];\r\n            }\r\n            else {\r\n                row[iter] = nextYCoeff;\r\n            }\r\n            resultsMatrix.push(row);\r\n            resultsColumn.push(Math.pow(stepSize, 2) * fResult - additionalConstant)\r\n        }\r\n        resultsInverse = inv(resultsMatrix);\r\n        resultsSolved = multiply(resultsInverse, resultsColumn);\r\n\r\n        for (let i = 0; i < iterations; i++) {\r\n            results.push({\r\n                currentX: (i === 0) ? initialVector[0] : xArray[i - 1],\r\n                newX: xArray[i],\r\n                currentY: (i === 0) ? initialVector[1] : resultsSolved[i - 1],\r\n                newY: (i === iterations - 1) ? initialVector[3] : resultsSolved[i]\r\n            });\r\n        }\r\n        let yColumnLatex = String.raw`\\left[\\begin{matrix} `;\r\n        for (let i = 1; i < iterations; i++) {\r\n            yColumnLatex += String.raw` y_{${i}}\\cr `;\r\n        }\r\n        yColumnLatex += String.raw` \\end{matrix}\\right] `;\r\n\r\n        const limit = 30;\r\n        const tooManyLatex = String.raw`\\left[\\begin{matrix}\r\n               & \\dots  &        \\cr\r\n        \\vdots & \\ddots & \\vdots \\cr\r\n               & \\dots  &        \\cr\r\n        \\end{matrix}\\right]`;\r\n        const tooManyColumnLatex = String.raw`\\left[\\begin{matrix}\r\n        \\vdots & \\cr\r\n        \\vdots & \\cr\r\n        \\vdots & \\cr\r\n        \\end{matrix}\\right]`;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& ${formatLatex(stepSize)}\r\n        \\\\ y_{0} &=& ${initialVector[1]}\r\n        \\\\ y_{${iterations}} &=& ${initialVector[3]}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\\\ \\text{From the equation } (1 + \\frac{h}{2} P_i) y_{i+1} + (h^{2} Q_{i} - 2) + (1 - \\frac{h}{2} P_i) y_{i-1} = h^{2} f_{i} \\text{ ,}\r\n        \\\\ \\begin{array}{rcl}\r\n        \\\\ ${iterations > limit ? tooManyLatex : matrixToLatex(resultsMatrix)} ${iterations > limit ? tooManyColumnLatex : yColumnLatex} &=& ${iterations > limit ? tooManyLatex : matrixToLatex(resultsColumn, { single: true })}\r\n        \\\\\r\n        \\\\                                 ${iterations > limit ? tooManyColumnLatex : yColumnLatex} &=& ${iterations > limit ? tooManyLatex : matrixToLatex(resultsColumn, { single: true })} ${iterations > limit ? \"\" : matrixToLatex(resultsInverse)}\r\n        \\\\\r\n        \\\\                                 ${yColumnLatex} &=& ${matrixToLatex(resultsSolved, { single: true })}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < iterations; i++) {\r\n                const r = results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { iterations, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`y^{''} + P(x)y^{'} + Q(x)y = f(x)`} />.\r\n                        </Typography>\r\n                        <Divider />\r\n                        <Grid xs item className=\"functions-display\">\r\n                            <Box border={1} borderRadius={5} boxShadow={2}>\r\n                                <Collapse in={!hasError}>\r\n                                    {!functionsError && <Fade triggerOnce>\r\n                                        <TeX math={String.raw`y^{''} + (${functionLatexs[0]}) y^{'} + (${functionLatexs[1]}) y = ${functionLatexs[2]}`} block />\r\n                                    </Fade>}\r\n                                </Collapse>\r\n                            </Box>\r\n                        </Grid>\r\n                        <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={String.raw`P(x)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={FUNCTIONS[0]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(0, mathField.text());\r\n                                                setSpecificFunctionLatex(0, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[0]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[0]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={String.raw`Q(x)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={FUNCTIONS[1]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(1, mathField.text());\r\n                                                setSpecificFunctionLatex(1, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[1]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[1]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            <TeX math={String.raw`F(x)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={FUNCTIONS[2]}\r\n                                            onChange={(mathField) => {\r\n                                                setSpecificFunctionText(2, mathField.text());\r\n                                                setSpecificFunctionLatex(2, mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionErrors[2]}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorTexts[2]}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                    <Collapse in={intervalError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {intervalErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"points-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Number of Points between Boundaries:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setPoints(parseInt(event.target.value))}\r\n                                            error={pointsError}\r\n                                            label={pointsError ? \"Error\" : \"\"}\r\n                                            defaultValue={points.toString()}\r\n                                            helperText={pointsErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"graph-button\">\r\n                                        <Slide direction=\"right\" triggerOnce>\r\n                                            <Graph params={{ currentIteration: 1, graphCallback, smallScreen, ...params }} />\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                        <Grid xs item className=\"step-math\">\r\n                                            <Zoom duration={500} triggerOnce>\r\n                                                <Card className={styleClasses.card}>\r\n                                                    <CardContent className={styleClasses.cardContent}>\r\n                                                        <TeX math={latexContent} block />\r\n                                                    </CardContent>\r\n                                                </Card>\r\n                                            </Zoom>\r\n                                        </Grid>\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default OdeFiniteDiff;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\System.js",["291"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix20 as initialMatrix, createNewColumn, generateGridCallback, gridTo2DArray, cloneArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect, useRef } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst ORDER_NAMES = ['x', 'y', 'u', 'v', 'w', 'z', 'p', 'q', 'r', 's', 't'];\r\nconst ORDER_FUNCTIONS = ['u', '-x u-y'];\r\nconst ORDER_FUNCTIONS_TEXT = ['u', '-x u-y'];\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order/Number of equations\",\r\n        content:\r\n            \"Specify the number of 1st order differential equations.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n            \"Choose either Euler or Runge-Kutta.\",\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Functions\",\r\n        content:\r\n            \"Type each function containing the relevant variables. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial values\",\r\n        content:\r\n            \"Specify the initial/starting values of each variable.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the selected method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeSystem({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Solver mode: Euler or Runge\r\n    const [solverType, setSolverType] = useState('runge');\r\n\r\n    // Order/ Number of equations\r\n    const [order, setOrder] = useState(2);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order < 2) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be 2 or higher.\";\r\n    }\r\n    else if (order > 9) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! A maximum of 9 is allowed for performance reasons.\";\r\n    }\r\n    const orderArray = [...Array(orderError ? 1 : order).keys()];\r\n    const validVariables = ORDER_NAMES.slice(0, order + 1);\r\n\r\n    // Functions\r\n    const [functionLatexs, setFunctionLatexs] = useState(ORDER_FUNCTIONS.slice());\r\n    const [functionTexts, setFunctionTexts] = useState(ORDER_FUNCTIONS_TEXT.slice());\r\n\r\n    const functionLatexsRef = useRef();\r\n    functionLatexsRef.current = functionLatexs;\r\n    const functionTextsRef = useRef();\r\n    functionTextsRef.current = functionTexts;\r\n\r\n    const setSpecificFunctionLatex = (i, value) => {\r\n        let modified = functionLatexsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionLatexs(modified);\r\n    }\r\n\r\n    const setSpecificFunctionText = (i, value) => {\r\n        let modified = functionTextsRef.current.slice();\r\n        modified[i] = value;\r\n        setFunctionTexts(modified);\r\n    }\r\n\r\n    let functionNodes = [];\r\n    let functionErrors = orderArray.slice().fill(false);\r\n    let functionErrorTexts = orderArray.slice().fill(\"\");\r\n\r\n    const testScope = validVariables.reduce((accumulated, v) => {\r\n        accumulated[v] = 0;\r\n        return accumulated;\r\n    }, {});\r\n\r\n    for (let i = 0; i < order; i++) {\r\n        if (orderError) {\r\n            break;\r\n        }\r\n        let funcNode;\r\n        try {\r\n            funcNode = parse(functionTexts[i]);\r\n            funcNode.traverse(function (node, path, parent) {\r\n                if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                    if (!validVariables.includes(node.name)) {\r\n                        throw \"variableName\";\r\n                    }\r\n                }\r\n            });\r\n            funcNode.evaluate(testScope);\r\n        }\r\n        catch (e) {\r\n            functionErrors[i] = true;\r\n            functionErrorTexts[i] = e === \"variableName\" ? `Only ${validVariables.join(',')} variables are allowed.` : \"Invalid equation!\";\r\n        }\r\n        functionNodes.push(funcNode);\r\n    }\r\n\r\n    // Grid/Initial values\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    let initialVector = { columns: [], rows: [{}] };\r\n\r\n    if (!orderError) {\r\n        const addVariableToVector = (variableName, variableValue) => {\r\n            const columns = initialVector.columns;\r\n            const rows = initialVector.rows;\r\n            columns.push(createNewColumn(columns.length, variableName));\r\n            let colName = `col_${columns.length}`;\r\n            rows[0][colName] = vectorState.rows[0].hasOwnProperty(colName) ? vectorState.rows[0][colName] : variableValue;\r\n        }\r\n        for (let i = 0; i <= order; i++) {\r\n            if (i <= 9) {\r\n                addVariableToVector(ORDER_NAMES[i], 0);\r\n            }\r\n        }\r\n        vectorState = initialVector;\r\n        initialVector = gridTo2DArray(vectorState.rows)[0];\r\n    }\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = !functionErrors.every((e) => e === false) || orderError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = { x: [], y: [] };\r\n    orderArray.forEach((i) => {\r\n        if (i !== 0) {\r\n            results[ORDER_NAMES[i + 1]] = [];\r\n        }\r\n    });\r\n    if (functionNodes.every((n) => isValidMath(n)) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results.x[iter - 1];\r\n            // Get current values\r\n            for (let k = 0; k < order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentValue = (iter === 0) ? initialVector[k + 1] : results[varName][iter - 1].newValue;\r\n                results[varName].push({\r\n                    currentValue,\r\n                });\r\n            }\r\n            // Find new values\r\n            if (solverType === 'runge') {\r\n                // k1\r\n                const originalScope = { x: currentX };\r\n                validVariables.filter((value, index) => index !== 0).forEach((value, index) => {\r\n                    originalScope[value] = results[value][iter].currentValue;\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k1 = functionNodes[k].evaluate(originalScope);\r\n                    results[varName][iter]['k1'] = k1;\r\n                }\r\n                // k2\r\n                const k2Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k2Scope[value] = k2Scope[value] + stepHalf;\r\n                    }\r\n                    else {\r\n                        k2Scope[value] = k2Scope[value] + stepHalf * results[value][iter].k1;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k2 = functionNodes[k].evaluate(k2Scope);\r\n                    results[varName][iter]['k2'] = k2;\r\n                }\r\n                // k3\r\n                const k3Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k3Scope[value] = k3Scope[value] + stepHalf;\r\n                    }\r\n                    else {\r\n                        k3Scope[value] = k3Scope[value] + stepHalf * results[value][iter].k2;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k3 = functionNodes[k].evaluate(k3Scope);\r\n                    results[varName][iter]['k3'] = k3;\r\n                }\r\n                // k4\r\n                const k4Scope = cloneArray(originalScope);\r\n                validVariables.forEach((value, index) => {\r\n                    if (index === 0) {\r\n                        k4Scope[value] = k4Scope[value] + stepSize;\r\n                    }\r\n                    else {\r\n                        k4Scope[value] = k4Scope[value] + stepSize * results[value][iter].k3;\r\n                    }\r\n                });\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const k4 = functionNodes[k].evaluate(k4Scope);\r\n                    results[varName][iter]['k4'] = k4;\r\n                }\r\n\r\n                // Find new values\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const currentValue = results[varName][iter].currentValue;\r\n                    const newValue = currentValue + stepSize / 6 * (results[varName][iter]['k1']\r\n                        + 2 * results[varName][iter]['k2']\r\n                        + 2 * results[varName][iter]['k3']\r\n                        + results[varName][iter]['k4']);\r\n                    results[varName][iter] = { ...results[varName][iter], newValue };\r\n                }\r\n            }\r\n            else {\r\n                for (let k = 0; k < order; k++) {\r\n                    const varName = ORDER_NAMES[k + 1];\r\n                    const currentValue = results[varName][iter].currentValue;\r\n                    const scope = { x: currentX, [varName]: currentValue };\r\n                    validVariables.filter((value, index) => index !== 0 && index !== k + 1).forEach((value, index) => {\r\n                        scope[value] = results[value][iter].currentValue;\r\n                    });\r\n                    const functionResult = functionNodes[k].evaluate(scope);\r\n                    const newValue = currentValue + stepSize * functionResult;\r\n                    results[varName][iter] = { ...results[varName][iter], newValue, functionResult };\r\n                }\r\n            }\r\n            const newX = currentX + stepSize;\r\n            results.x.push(newX);\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatexs, solverType, order, validVariables, initialVector, stepSize, iterations, results, smallScreen };\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied to 1st order differential equations of the form &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                            <br />\r\n                            Up to 9 equations are supported, so even 9th order differential equation can be solved.\r\n                        </Typography>\r\n                        <Grid container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"order-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Order / Number of equations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setOrder(parseInt(event.target.value))}\r\n                                            error={orderError}\r\n                                            label={orderError ? \"Error\" : \"\"}\r\n                                            defaultValue={order.toString()}\r\n                                            helperText={orderErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <Typography variant=\"h6\">\r\n                                    Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                </Typography>\r\n                                <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event) => setSolverType(event.target.value)}>\r\n                                    <FormControlLabel value=\"euler\" control={<Radio />} label=\"Euler\" />\r\n                                    <FormControlLabel value=\"runge\" control={<Radio />} label=\"Runge-Kutta\" />\r\n                                </RadioGroup>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid className=\"function-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            {order < 10 && orderArray.map((i) =>\r\n                                <Grid key={\"function\" + i} xs item>\r\n                                    <Card className={styleClasses.card}>\r\n                                        <CardContent className={styleClasses.cardContent}>\r\n                                            <Typography variant=\"h6\">\r\n                                                <TeX math={i === 0 ? String.raw`y^{'}, \\frac{dy}{dx}` : String.raw`${ORDER_NAMES[i + 1]}^{'}, \\frac{d${ORDER_NAMES[i + 1]}}{dx}`} />\r\n                                            </Typography>\r\n                                            <EditableMathField\r\n                                                disabled={false}\r\n                                                latex={ORDER_FUNCTIONS[i]}\r\n                                                onChange={(mathField) => {\r\n                                                    setSpecificFunctionText(i, mathField.text());\r\n                                                    setSpecificFunctionLatex(i, mathField.latex());\r\n                                                }}\r\n                                                mathquillDidMount={(mathField) => {\r\n                                                }}\r\n                                            />\r\n                                            <Collapse in={functionErrors[i]}>\r\n                                                <Alert severity=\"error\">\r\n                                                    {functionErrorTexts[i]}\r\n                                                </Alert>\r\n                                            </Collapse>\r\n                                        </CardContent>\r\n                                    </Card>\r\n                                </Grid>\r\n                            )}\r\n                        </Grid>\r\n\r\n                        <Grid className=\"initialVector-input\" container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial Values:\r\n                                        </Typography>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        const results = params.results;\r\n        const currentX = (currentIteration === 1) ? params.initialVector[0] : results.x[currentIteration - 2];\r\n        const newX = results.x[currentIteration - 1];\r\n\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(newX)}\r\n        \\end{array}\r\n        `;\r\n        if (params.solverType === 'runge') {\r\n            // k1\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}}`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{1${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k1)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k2\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{1${value}}`} (\\frac{h}{2})`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{2${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k2)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k3\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{2${value}}`} (\\frac{h}{2})`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{3${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k3)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // k4\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline`;\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}} + ${index === 0 ? '' : `k_{3${value}}`} (h)`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ k_{4${varName}} &=& ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\                 &=& ${formatLatex(currentResult.k4)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n\r\n            // Find new values\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ ${varName}^{'} = \\frac{d${varName}}{dx} = ${params.functionLatexs[k]}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${varName}_{${currentIteration}} &=& ${varName}_{${currentIteration - 1}} + \\frac{h}{6} ( k_{1${varName}} + 2 k_{2${varName}} + 2 k_{3${varName}} + k_{4${varName}} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.currentValue)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.newValue)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            for (let k = 0; k < params.order; k++) {\r\n                const varName = ORDER_NAMES[k + 1];\r\n                const currentResult = results[varName][currentIteration - 1];\r\n                const argumentsLatex = params.validVariables.map((value, index) => {\r\n                    return String.raw`${value}_{${currentIteration - 1}}`;\r\n                }).join(',');\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ ${varName}^{'} = \\frac{d${varName}}{dx} = ${params.functionLatexs[k]}\r\n                \\\\\r\n                \\begin{array}{lcl}\r\n                \\\\ ${varName}_{${currentIteration}} &=& ${varName}_{${currentIteration - 1}} + h \\cdot ${varName}^{'} ( ${argumentsLatex} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.currentValue)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n                \\\\\r\n                \\\\                         &=& ${formatLatex(currentResult.newValue)}\r\n                \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult, currentIteration) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results['y'][i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${params.initialVector[0]}, ${r.currentValue})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${results.x[i]}, ${r.newValue})`\r\n                });\r\n            }\r\n            const currentX = (currentIteration === 1) ? params.initialVector[0] : results.x[currentIteration - 2];\r\n            const newX = results.x[currentIteration - 1];\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newValue})/(x-${newX})=${(currentResult.newValue - currentResult.currentValue) / (newX - currentX)} \\left\\{${currentX}<x<${newX}\\right\\} \\left\\{${currentResult.currentValue}<y<${currentResult.newValue}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentX}, ${currentResult.currentValue})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${newX}, ${currentResult.newValue})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction=\"column\" alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeSystem;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Runge.js",["292"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeRunge({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0, y: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const k1 = functionNode.evaluate({ x: currentX, y: currentY });\r\n            const k2 = functionNode.evaluate({ x: currentX + stepHalf, y: currentY + k1 * stepHalf });\r\n            const k3 = functionNode.evaluate({ x: currentX + stepHalf, y: currentY + k2 * stepHalf });\r\n            const k4 = functionNode.evaluate({ x: currentX + stepSize, y: currentY + k3 * stepSize });\r\n            const newY = currentY + stepSize / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                k1,\r\n                k2,\r\n                k3,\r\n                k4,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, initialVector, stepSize, iterations, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ k_1 &=& f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n        \\\\    &=& ${formatLatex(currentResult.k1)}\r\n        \\\\\r\n        \\\\ k_2 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_1 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k2)}\r\n        \\\\\r\n        \\\\ k_3 &=& f(x_{${currentIteration - 1}} + \\frac{h}{2}, y_{${currentIteration - 1}} + k_2 \\frac{h}{2})\r\n        \\\\    &=& ${formatLatex(currentResult.k3)}\r\n        \\\\\r\n        \\\\ k_4 &=& f(x_{${currentIteration - 1}} + h, y_{${currentIteration - 1}} + k_1 \\cdot h)\r\n        \\\\    &=& ${formatLatex(currentResult.k4)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentResult.k1)} + 2 (${formatLatex(currentResult.k2)}) + 2 (${formatLatex(currentResult.k3)}) + ${formatLatex(currentResult.k4)} )\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array} \\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeRunge;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Multistep.js",["293"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeMultistep({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    let variables = new Set(); // Unique set of variables\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n                variables.add(node.name);\r\n            }\r\n            functionNode.evaluate({ x: 0, y: 0 });\r\n        });\r\n        variables = [...variables].sort(); // Alphabetical order\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.2);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let initialYValues = [initialVector[1]];\r\n    let rungeResults = [];\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const stepHalf = stepSize / 2;\r\n        for (let i = 1; i <= 3; i++) {\r\n            // Runge-Kutta for the first 4 y values\r\n            const currentX = (i === 1) ? initialVector[0] : rungeResults[i - 2].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = initialYValues[i - 1];\r\n            const k1 = functionNode.evaluate({ x: currentX, y: currentY });\r\n            const k2 = functionNode.evaluate({ x: currentX + stepHalf, y: currentY + k1 * stepHalf });\r\n            const k3 = functionNode.evaluate({ x: currentX + stepHalf, y: currentY + k2 * stepHalf });\r\n            const k4 = functionNode.evaluate({ x: currentX + stepSize, y: currentY + k3 * stepSize });\r\n            const newY = currentY + stepSize / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\r\n            initialYValues.push(newY);\r\n            rungeResults.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                k1,\r\n                k2,\r\n                k3,\r\n                k4,\r\n            });\r\n        }\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] + stepSize * 3 : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            let yValues;\r\n            if (iter < 4) {\r\n                yValues = [...initialYValues.slice(iter, 4), ...results.slice(0, iter).map((v) => v.newY)];\r\n            }\r\n            else {\r\n                yValues = results.slice(iter - 4, iter).map((v) => v.newY);\r\n            }\r\n            const f3 = functionNode.evaluate({ x: currentX, y: yValues[3] });\r\n            const f2 = functionNode.evaluate({ x: currentX - stepSize, y: yValues[2] });\r\n            const f1 = functionNode.evaluate({ x: currentX - 2 * stepSize, y: yValues[1] });\r\n            const f0 = functionNode.evaluate({ x: currentX - 3 * stepSize, y: yValues[0] });\r\n            const tempY = yValues[3] + stepSize / 24 * (55 * f3 - 59 * f2 + 37 * f1 - 9 * f0);\r\n            const fTemp = functionNode.evaluate({ x: newX, y: tempY });\r\n            const newY = yValues[3] + stepSize / 24 * (9 * fTemp + 19 * f3 - 5 * f2 + f1);\r\n            results.push({\r\n                currentX,\r\n                yValues,\r\n                newX,\r\n                newY,\r\n                tempY,\r\n                fTemp,\r\n                f3,\r\n                f2,\r\n                f1,\r\n                f0,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, initialVector, stepSize, iterations, initialYValues, rungeResults, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\`;\r\n        if (currentIteration === 1) {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{First, we apply 4th order Runge-Kutta to obtain } y_{0}, y_{-1}, \\text{ and } y_{-2}:\r\n            \\end{array}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ x_{-3} &=& ${params.rungeResults[0].currentX}, \\\\ y_{-3} &=& ${params.rungeResults[0].currentY}`;\r\n            for (let i = 1; i <= 3; i++) {\r\n                const currentRungeResult = params.rungeResults[i - 1];\r\n                // Runge-Kutta for the first 4 y values\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ x_{${i - 3}} &=& ${formatLatex(currentRungeResult.newX)}, \\\\ y_{${i - 3}} &=& y_{${i - 4}} + \\frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 )\r\n                \\\\\r\n                \\\\              &=& ${formatLatex(currentRungeResult.currentY)} + \\frac{${params.stepSize}}{6} ( ${formatLatex(currentRungeResult.k1)} + 2 (${formatLatex(currentRungeResult.k2)}) + 2 (${formatLatex(currentRungeResult.k3)}) + ${formatLatex(currentRungeResult.k4)} )\r\n                \\\\\r\n                \\\\              &=& ${formatLatex(currentRungeResult.newY)}`;\r\n            }\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Now, we can initiate the Adams-Moulton method.}`;\r\n        }\r\n\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}}^{*} &=& y_{${currentIteration - 1}} + \\frac{h}{24} ( 55 f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n                                                                                        - 59 f(x_{${currentIteration - 2}}, y_{${currentIteration - 2}})\r\n                                                                                        + 37 f(x_{${currentIteration - 3}}, y_{${currentIteration - 3}})\r\n                                                                                        - 9 f(x_{${currentIteration - 4}}, y_{${currentIteration - 4}}) )\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.yValues[3])} + \\frac{${formatLatex(params.stepSize)}}{24} [ 55 (${formatLatex(currentResult.f3)})\r\n                                                                                                           - 59 (${formatLatex(currentResult.f2)})\r\n                                                                                                           + 37 (${formatLatex(currentResult.f1)})\r\n                                                                                                           - 9 (${formatLatex(currentResult.f0)}) ]\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.tempY)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{24} ( 9 f(x_{${currentIteration}}, y_{${currentIteration}}^{*})\r\n                                                                                    + 19 f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n                                                                                    - 5 f(x_{${currentIteration - 2}}, y_{${currentIteration - 2}})\r\n                                                                                    + 1 f(x_{${currentIteration - 3}}, y_{${currentIteration - 3}}) )\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.yValues[3])} + \\frac{${formatLatex(params.stepSize)}}{24} [ 9 (${formatLatex(currentResult.fTemp)})\r\n                                                                                                    + 19 (${formatLatex(currentResult.f3)})\r\n                                                                                                    - 5 (${formatLatex(currentResult.f2)})\r\n                                                                                                    + 1 (${formatLatex(currentResult.f1)}) ]\r\n        \\\\\r\n        \\\\      &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < 3; i++) {\r\n                const r = params.rungeResults[i];\r\n                calculator.current.setExpression({\r\n                    id: \"Runge\" + i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.currentX}, ${r.currentY})`\r\n                });\r\n            }\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.yValues[3]})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            const currentY = currentResult.yValues[3];\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeMultistep;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Taylor.js",["294","295","296"],"import { isValidMath, formatLatex, mathjsToLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix19 as initialMatrix, generateGridCallback, gridTo2DArray, numberFactorials } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the maximum differential order.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply this method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeTaylor({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`2xy`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0, y: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 10) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! It is limited to 10! for performance reasons.\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || orderError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let derivNodes = [functionNode];\r\n    let derivLatex = String.raw`\\displaystyle\r\n    \\begin{array}{l}\r\n    \\\\ y^{'} = ${functionLatex}\r\n    `;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        for (let i = 1; i < order; i++) {\r\n            derivNodes.push(derivative(derivNodes[i - 1], 'x'));\r\n            derivLatex += String.raw`\r\n            \\\\ y^{${`'`.repeat(i + 1)}} = ${mathjsToLatex(derivNodes[i])}`;\r\n        }\r\n        derivLatex += String.raw`\\end{array}`;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            let newY = currentY;\r\n            let derivResults = [];\r\n            for (let i = 1; i <= order; i++) {\r\n                const result = derivNodes[i - 1].evaluate({ x: currentX, y: currentY });\r\n                derivResults.push(result);\r\n                newY += Math.pow(stepSize, i) * result / numberFactorials[i];\r\n            }\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                derivResults,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, order, initialVector, stepSize, iterations, derivNodes, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"derivative-display\">\r\n                                <Box border={1} borderRadius={5} boxShadow={2}>\r\n                                    <Collapse in={functionError}>\r\n                                        <Alert severity=\"error\">\r\n                                            {functionErrorText}\r\n                                        </Alert>\r\n                                    </Collapse>\r\n                                    <Collapse in={!functionError}>\r\n                                        {!functionError && <Fade triggerOnce>\r\n                                            <TeX math={derivLatex} block />\r\n                                        </Fade>}\r\n                                    </Collapse>\r\n                                </Box>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"order-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Order:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setOrder(parseInt(event.target.value))}\r\n                                            error={orderError}\r\n                                            label={orderError ? \"Error\" : \"\"}\r\n                                            defaultValue={order.toString()}\r\n                                            helperText={orderErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n\r\n        let formulaLatex = String.raw`h y_{${currentIteration - 1}}^{'}`;\r\n        let valuesLatex = String.raw`${params.stepSize} (${formatLatex(currentResult.derivResults[0])})`;\r\n        for (let i = 2; i <= params.order; i++) {\r\n            //derivLatex += String.raw`\\\\ y^{${`'`.repeat(i + 1)}} = ${mathjsToLatex(params.derivNodes[i])}`;\r\n            formulaLatex += String.raw`+ \\frac{h^{${i}}}{${i}!} y_{${currentIteration - 1}}^{${`'`.repeat(i)}}`;\r\n            valuesLatex += String.raw`+ \\frac{${params.stepSize}^{${i}}}{${numberFactorials[i]}} ( ${formatLatex(currentResult.derivResults[i - 1])} )`;\r\n        }\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + ${formulaLatex}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${valuesLatex}\r\n        \\\\\r\n        \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        latexContent += String.raw`\r\n\r\n\r\n        `;\r\n        latexContent += String.raw`\r\n    \r\n        `\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeTaylor;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\MonteCarlo.js",["297"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Button from '@material-ui/core/Button';\r\nimport ReplayIcon from '@material-ui/icons/Replay';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".points-input\",\r\n        title: \"Random Points\",\r\n        content:\r\n            \"Specify the number of random points.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".regenerate-button\",\r\n        title: \"Regenerate Random Points\",\r\n        content:\r\n            \"Click this to regenerate random points.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralMonteCarlo({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Random Points\r\n    const [points, setPoints] = useState(10000);\r\n    let pointsError = false;\r\n    let pointsErrorText = \"\";\r\n    if (isNaN(points) || !Number.isInteger(points) || points <= 0) {\r\n        pointsError = true;\r\n        pointsErrorText = \"Random points must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || pointsError;\r\n\r\n    // Solve\r\n    const plotDesmosPoints = 200;\r\n    let latexContent, graphCallback;\r\n    let results = [];\r\n    let solve = false;\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n\r\n        let yMin = 0;\r\n        let yMax = 0;\r\n\r\n        const divisions = 250;\r\n        const multiple = (upperX - lowerX) / divisions;\r\n\r\n        for (let i = 0; i <= divisions; i++) {\r\n            const x = lowerX + i * multiple;\r\n            const y = functionNode.evaluate({ x: x });\r\n            if (y > yMax) {\r\n                yMax = y;\r\n            }\r\n            else if (y < yMin) {\r\n                yMin = y;\r\n            }\r\n        }\r\n\r\n        const paddingX = 0;\r\n        const paddingY = 0;\r\n        let pointsInsidePositive = 0;\r\n        let pointsInsideNegative = 0;\r\n\r\n        for (let i = 0; i < points; i++) {\r\n            const randomX = lowerX - paddingX + (upperX - lowerX + 2 * paddingX) * Math.random();\r\n            const actualY = functionNode.evaluate({ x: randomX });\r\n            const randomY = yMin - paddingY + (yMax - yMin + 2 * paddingY) * Math.random();\r\n            let inside = false;\r\n            if (actualY >= 0 && randomY >= 0 && randomY <= actualY) {\r\n                inside = true;\r\n                pointsInsidePositive += 1;\r\n            }\r\n            else if (actualY < 0 && randomY < 0 && randomY >= actualY) {\r\n                inside = true;\r\n                pointsInsideNegative += 1;\r\n            }\r\n            results.push({ x: randomX, y: randomY, inside });\r\n        }\r\n        const rectArea = (yMax - yMin) * (upperX - lowerX);\r\n        const positiveIntegral = rectArea * pointsInsidePositive / points;\r\n        const negativeIntegral = rectArea * pointsInsideNegative / points;\r\n        const integralResult = positiveIntegral - negativeIntegral;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ y_{max} = ${formatLatex(yMax)}\r\n        \\\\ y_{min} = ${formatLatex(yMin)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Rectangle area} &=& y_{max} \\cdot y_{min} \\cdot x_{lower} \\cdot y_{upper}\r\n        \\\\                       &=&= ${formatLatex(rectArea)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Points inside positive area} &=& ${formatLatex(pointsInsidePositive)}\r\n        \\\\ \\text{Points inside negative area} &=& ${formatLatex(pointsInsideNegative)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Positive area}&=& \\text{Rectangle area} \\cdot \\frac{\\text{Points inside positive area}}{\\text{Total points}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(rectArea)} \\cdot \\frac{${formatLatex(pointsInsidePositive)}}{${formatLatex(points)}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(positiveIntegral)}\r\n        \\\\\r\n        \\\\ \\text{Negative area}&=& \\text{Rectangle area} \\cdot \\frac{\\text{Points inside negative area}}{\\text{Total points}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(rectArea)} \\cdot \\frac{${formatLatex(pointsInsideNegative)}}{${formatLatex(points)}}\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(negativeIntegral)}\r\n        \\\\\r\n        \\\\ \\text{Total area/integral} &=& \\text{Positive area} - \\text{Negative area}\r\n        \\\\                   &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\" + functionLatex });\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\" + lowerX });\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\" + upperX });\r\n            calculator.current.setExpression({ id: 'shadedArea', latex: String.raw`\\left\\{f\\left(x\\right)>0:\\ 0,\\ f\\left(x\\right)<0:\\ f\\left(x\\right)\\right\\}<y<\\ \\left\\{f\\left(x\\right)>0:\\ f\\left(x\\right),\\ f\\left(x\\right)<0:\\ 0\\right\\}\\left\\{a<x<b,\\ b<x<a\\right\\}` });\r\n            calculator.current.setExpression({ id: 'leftVertical', color: Desmos.Colors.ORANGE, latex: String.raw`x=${lowerX} \\left\\{${yMin}<y<${yMax}\\right\\}` });\r\n            calculator.current.setExpression({ id: 'rightVertical', color: Desmos.Colors.ORANGE, latex: String.raw`x=${upperX} \\left\\{${yMin}<y<${yMax}\\right\\}` });\r\n            calculator.current.setExpression({ id: 'upperHori', color: Desmos.Colors.ORANGE, latex: String.raw`y=${yMax} \\left\\{${lowerX}<x<${upperX}\\right\\}` });\r\n            calculator.current.setExpression({ id: 'lowerHori', color: Desmos.Colors.ORANGE, latex: String.raw`y=${yMin} \\left\\{${lowerX}<x<${upperX}\\right\\}` });\r\n            if (results.length > plotDesmosPoints) {\r\n                for (let i = 0; i < plotDesmosPoints; i++) {\r\n                    const value = results[Math.floor(Math.random() * results.length)];\r\n                    calculator.current.setExpression({ id: `r${i}`, color: value.inside ? Desmos.Colors.GREEN : Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, latex: `(${value.x}, ${value.y})` });\r\n                }\r\n            }\r\n            else {\r\n                results.forEach((value, i) => {\r\n                    calculator.current.setExpression({ id: `r${i}`, color: value.inside ? Desmos.Colors.GREEN : Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, latex: `(${value.x}, ${value.y})` });\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    const [regenerate, setRegenerate] = useState(false); // For the purpose of refreshing the data\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"points-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Random points:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setPoints(parseInt(event.target.value))}\r\n                                            error={pointsError}\r\n                                            label={pointsError ? \"Error\" : \"\"}\r\n                                            defaultValue={points.toString()}\r\n                                            helperText={pointsErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Button className=\"regenerate-button\" variant=\"contained\" color=\"primary\" endIcon={<ReplayIcon />} onClick={() => setRegenerate(!regenerate)}>\r\n                                    Regenerate\r\n                                </Button>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item className=\"graph-button\">\r\n\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralMonteCarlo;","F:\\numerical-methods-js\\src\\components\\methods\\ode\\Euler.js",["298","299","300","301","302","303","304"],"import { isValidMath, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix18 as initialMatrix, generateGridCallback, gridTo2DArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Checkbox from '@material-ui/core/Checkbox';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".heun-input\",\r\n        title: \"Heun's method\",\r\n        content:\r\n            \"If checked, Heun's method will be used instead of the default Euler's method.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variables x and/or y. cos, sin and e are supported.\",\r\n    },\r\n    {\r\n        target: \".initialVector-input\",\r\n        title: \"Initial x and y value\",\r\n        content:\r\n            \"Specify the initial/starting value of x and y.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size, h.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Euler's method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OdeEuler({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Heun mode\r\n    const [heunMode, setHeunMode] = useState(true);\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x+y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x' && node.name !== 'y') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0, y: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x and y variables are allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Grid/Vector\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    let [vectorState, setVectorState] = useState(initialMatrix);\r\n    const initialVector = gridTo2DArray(vectorState.rows)[0];\r\n\r\n    // Step size\r\n    const [stepSize, setStepSize] = useState(0.1);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize)) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be a number!\";\r\n    }\r\n    else if (stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size must be greater than zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || stepSizeError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const currentX = (iter === 0) ? initialVector[0] : results[iter - 1].newX;\r\n            const newX = currentX + stepSize;\r\n            const currentY = (iter === 0) ? initialVector[1] : results[iter - 1].newY;\r\n            const functionResult = functionNode.evaluate({ x: currentX, y: currentY });\r\n            let functionResultHeun, tempY;\r\n            let newY = currentY + stepSize * functionResult;\r\n            if (heunMode) {\r\n                functionResultHeun = functionNode.evaluate({ x: newX, y: newY });\r\n                tempY = newY;\r\n                newY = currentY + stepSize / 2 * (functionResult + functionResultHeun);\r\n            }\r\n            results.push({\r\n                currentX,\r\n                currentY,\r\n                newX,\r\n                newY,\r\n                tempY,\r\n                functionResult,\r\n                functionResultHeun\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, heunMode, initialVector, stepSize, iterations, results, smallScreen };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied in the form of &nbsp;\r\n                            <TeX math={String.raw`\\frac{dy}{dx}=f(x)`} />.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, <TeX math={String.raw`f(x, y)`} />:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"heun-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                <FormControlLabel\r\n                                    control={<Checkbox checked={heunMode} onChange={(event) => setHeunMode(event.target.checked)} name=\"heunMode\" />}\r\n                                    label=\"Use Heun's Method\"\r\n                                />\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialVector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Values:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let currentResult = params.results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\frac{dy}{dx} = ${params.functionLatex}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ x_{${currentIteration}} &=& x_{${currentIteration - 1}} + h\r\n        \\\\                         &=& ${formatLatex(currentResult.currentX)} + ${formatLatex(params.stepSize)}\r\n        \\\\                         &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        `;\r\n\r\n        if (params.heunMode) {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}}^{*} &=& y_{${currentIteration - 1}} + h \\cdot f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.tempY)}\r\n            \\end{array}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + \\frac{h}{2} ( f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}}) + f(x_{${currentIteration}}, y_{${currentIteration}}^{*}) )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + \\frac{${formatLatex(params.stepSize)}}{2} ( ${formatLatex(currentResult.functionResult)} + ${formatLatex(currentResult.functionResultHeun)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\begin{array}{lcl}\r\n            \\\\ y_{${currentIteration}} &=& y_{${currentIteration - 1}} + h \\cdot f(x_{${currentIteration - 1}}, y_{${currentIteration - 1}})\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.currentY)} + ${formatLatex(params.stepSize)} ( ${formatLatex(currentResult.functionResult)} )\r\n            \\\\\r\n            \\\\                         &=& ${formatLatex(currentResult.newY)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\\end{array}`;\r\n        graphCallback = (calculator, currentResult) => {\r\n            for (let i = 0; i < params.iterations; i++) {\r\n                const r = params.results[i];\r\n                if (i === 0) {\r\n                    calculator.current.setExpression({\r\n                        id: \"starting\", color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                            `(${r.currentX}, ${r.currentY})`\r\n                    });\r\n                }\r\n                calculator.current.setExpression({\r\n                    id: i, color: Desmos.Colors.BLUE, pointStyle: Desmos.Styles.POINT, latex:\r\n                        `(${r.newX}, ${r.newY})`\r\n                });\r\n            }\r\n            calculator.current.setExpression({\r\n                id: 'line', color: Desmos.Colors.GREEN, latex:\r\n                    String.raw`(y-${currentResult.newY})/(x-${currentResult.newX})=${(currentResult.newY - currentResult.currentY) / (currentResult.newX - currentResult.currentX)} \\left\\{${currentResult.currentX}<x<${currentResult.newX}\\right\\} \\left\\{${currentResult.currentY}<y<${currentResult.newY}\\right\\}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"initial\", color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"Initial\", showLabel: true, latex:\r\n                    `(${currentResult.currentX}, ${currentResult.currentY})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: \"final\", color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Final\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, ${currentResult.newY})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = params.smallScreen;\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OdeEuler;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Simpson.js",["305"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".subIntervals-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the number of subintervals, N, which must be even.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralSimpson({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Subintervals\r\n    const [subIntervals, setSubIntervals] = useState(10);\r\n    let subIntervalsError = false;\r\n    let subIntervalsErrorText = \"\";\r\n    if (isNaN(subIntervals) || !Number.isInteger(subIntervals) || subIntervals <= 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be a positive integer!\";\r\n    }\r\n    else if (subIntervals % 2 !== 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be an even integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || subIntervalsError;\r\n\r\n    // Solve\r\n    let latexContent, graphCallback;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        const width = (upperX - lowerX) / subIntervals;\r\n        let integralResult = 0;\r\n        let results = [];\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            const x = lowerX + i * width;\r\n            let f = functionValue.evaluate({ x: x });\r\n            if (i === 0 || i === subIntervals) {\r\n                integralResult += f;\r\n                results.push(f);\r\n            }\r\n            else {\r\n                if (i % 2 === 0) {\r\n                    integralResult += 2 * f;\r\n                    results.push(2 * f);\r\n                }\r\n                else {\r\n                    integralResult += 4 * f;\r\n                    results.push(4 * f);\r\n                }\r\n            }\r\n        }\r\n        integralResult *= width / 3;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& \\frac{ x_{upper} - x_{lower} }{N}\r\n        \\\\   &=& ${formatLatex(width)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ x_i = x_{lower} + i \\cdot h\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\frac{h}{3} [f(x_0) + 4 \\sum_{i=1, odd}^{${subIntervals - 1}} f(x_i) + 2 \\sum_{j=2, even}^{${subIntervals - 2}} f(x_j) + f(x_{${subIntervals}})]\r\n        \\\\`;\r\n        latexContent += String.raw`\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            let coefficient = \"\";\r\n            if (i > 0 && i < subIntervals) {\r\n                if (i % 2 === 0) {\r\n                    coefficient = \"2\";\r\n                }\r\n                else {\r\n                    coefficient = \"4\";\r\n                }\r\n            }\r\n            latexContent += String.raw`${coefficient}f(${formatLatex(lowerX + i * width)}) ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(width / 3)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${formatLatex(results[i])} ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\" + functionLatex });\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\" + lowerX });\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\" + upperX });\r\n            calculator.current.setExpression({ id: 'n', latex: \"n=\" + subIntervals });\r\n            calculator.current.setExpression({ id: 'g', latex: String.raw`g\\left(x\\right)=f\\left(x\\right)\\left\\{a\\le x\\le b\\right\\}` });\r\n            calculator.current.setExpression({ id: 'shade', color: Desmos.Colors.BLACK, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,g\\left(x\\right)\\right)\\le y\\le\\max\\left(0,g\\left(x\\right)\\right)` });\r\n            calculator.current.setExpression({ id: 'i', latex: String.raw`i=\\left[1...n\\right]` });\r\n            calculator.current.setExpression({ id: 'sOdd', latex: String.raw`S_{i3}=\\left[2,4,...n\\right]` });\r\n            calculator.current.setExpression({ id: 'x1', latex: String.raw`x_{1}=a+\\left(S_{i3}-2\\right)\\frac{b-a}{n}` });\r\n            calculator.current.setExpression({ id: 'x2', latex: String.raw`x_{2}=a+\\left(S_{i3}-1\\right)\\frac{b-a}{n}` });\r\n            calculator.current.setExpression({ id: 'x3', latex: String.raw`x_{3}=a+S_{i3}\\frac{b-a}{n}` });\r\n            calculator.current.setExpression({ id: 'simpsonShade', color: Desmos.Colors.RED, lineStyle: Desmos.Styles.DASHED, latex: String.raw`\\min\\left(0,P\\left(x\\right)\\right)\\le y\\le\\max\\left(0,P\\left(x\\right)\\right)\\left\\{x_{1}\\le x\\le x_{3}\\right\\}` });\r\n            calculator.current.setExpression({ id: 'xLine1', color: Desmos.Colors.RED, latex: String.raw`x=a+\\left(i-1\\right)\\frac{b-a}{n}\\left\\{\\min\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\le y\\le\\max\\left(0,f\\left(a+\\left(i-1\\right)\\frac{b-a}{n}\\right)\\right)\\right\\}` });\r\n            calculator.current.setExpression({ id: 'xLine2', color: Desmos.Colors.RED, latex: String.raw`x=b\\left\\{\\min\\left(0,f\\left(b\\right)\\right)\\le y\\le\\max\\left(0,f\\left(b\\right)\\right)\\right\\}` });\r\n            calculator.current.setExpression({ id: 'sn', latex: String.raw`S_{n}=\\frac{1}{3}\\cdot\\frac{b-a}{n}\\left(f\\left(a\\right)+\\sum_{t=1}^{\\frac{n}{2}}4f\\left(a+\\left(2t-1\\right)\\frac{b-a}{n}\\right)+\\sum_{t=1}^{\\frac{n}{2}-1}2f\\left(a+2t\\frac{b-a}{n}\\right)+f\\left(b\\right)\\right)` });\r\n            calculator.current.setExpression({ id: 'p', latex: String.raw`P\\left(x\\right)=f\\left(x_{1}\\right)\\cdot\\frac{x-x_{2}}{x_{1}-x_{2}}\\cdot\\frac{x-x_{3}}{x_{1}-x_{3}}+f\\left(x_{2}\\right)\\cdot\\frac{x-x_{1}}{x_{2}-x_{1}}\\cdot\\frac{x-x_{3}}{x_{2}-x_{3}}+f\\left(x_{3}\\right)\\cdot\\frac{x-x_{1}}{x_{3}-x_{1}}\\cdot\\frac{x-x_{2}}{x_{3}-x_{2}}\\left\\{x_{1}\\le x\\le x_{3}\\right\\}` });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            If even subintervals, 2nd order polynomial/parabola.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"subIntervals-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Subintervals, N:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setSubIntervals(parseInt(event.target.value))}\r\n                                            error={subIntervalsError}\r\n                                            label={subIntervalsError ? \"Error\" : \"\"}\r\n                                            defaultValue={subIntervals.toString()}\r\n                                            helperText={subIntervalsErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item className=\"graph-button\">\r\n\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralSimpson;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Quadrature.js",["306"],"import { isValidMath, mathjsToLatex, formatLatex, mathjsKeywords, gaussPoints } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, simplify } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Table from '@material-ui/core/Table';\r\nimport TableBody from '@material-ui/core/TableBody';\r\nimport TableCell from '@material-ui/core/TableCell';\r\nimport TableHead from '@material-ui/core/TableHead';\r\nimport TableRow from '@material-ui/core/TableRow';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".points-slider\",\r\n        title: \"Gauss points\",\r\n        content:\r\n            \"Choose the number of Gauss points, N, which range from 2 to 6 in this demo.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".point-table\",\r\n        title: \"Gauss points table\",\r\n        content:\r\n            \"The Gauss points and their coefficients are shown here.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralQuadrature({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`e^{-x^2}`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionNode.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(0);\r\n    const [upperX, setUpperX] = useState(3);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Points\r\n    const [points, setPoints] = useState(4);\r\n\r\n    let hasError = functionError || intervalError;\r\n\r\n    // Solve\r\n    let latexContent;\r\n    const p = gaussPoints[points];\r\n    let solve = false;\r\n    if (isValidMath(functionNode) && !hasError) {\r\n        solve = true;\r\n        const transformNode = parse(`1/2*(t * (${upperX} - ${lowerX}) + ${lowerX} + ${upperX} )`);\r\n        const simplifiedTransformNode = simplify(transformNode);\r\n        const factor = (upperX - lowerX) / 2;\r\n        let transformedFunction = functionNode.transform(function (node, path, parent) {\r\n            if (node.isSymbolNode && !mathjsKeywords.includes(node.name) && node.name === 'x') {\r\n                return simplifiedTransformNode;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        });\r\n        transformedFunction = parse(String.raw`${factor} * ${transformedFunction.toString()}`);\r\n        let integralResult = 0;\r\n        let functionResults = [];\r\n        for (let i = 0; i < points; i++) {\r\n            const f = transformedFunction.evaluate({ t: p.x[i] });\r\n            functionResults.push(f);\r\n            integralResult += p.c[i] * f;\r\n        }\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\text{First, we transform the integral from variable x to variable t:}\r\n        \\\\ \\begin{array}{lcl}\r\n        \\\\ x &=& \\frac{1}{2} [t(x_{upper} - x_{lower}) + x_{lower} + x_{upper}]\r\n        \\\\\r\n        \\\\   &=& ${mathjsToLatex(simplifiedTransformNode)}\r\n        \\\\\r\n        \\\\ dx &=& \\frac{1}{2} (x_{upper} - x_{lower}) dt\r\n        \\\\\r\n        \\\\   &=& ${factor} dt\r\n        \\end{array}\r\n        \\\\ \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\int_{-1}^{1} ${mathjsToLatex(transformedFunction)} dt\r\n        \\\\\r\n        \\\\                                      &=&\r\n        `;\r\n        for (let i = 1; i <= points; i++) {\r\n            latexContent += String.raw`C_{${i}} f(t_{${i}}) ${i < points ? \"+\" : \"\"}`;\r\n        }\r\n        latexContent += String.raw`\\\\ \\\\ &=&`;\r\n        for (let i = 0; i < points; i++) {\r\n            latexContent += String.raw`(${formatLatex(p.c[i])}) f(${formatLatex(p.x[i])}) ${i < points - 1 ? \"+\" : \"\"}`;\r\n        }\r\n        latexContent += String.raw`\\\\ \\\\ &=&`;\r\n        for (let i = 0; i < points; i++) {\r\n            latexContent += String.raw`(${formatLatex(p.c[i])}) (${formatLatex(functionResults[i])}) ${i < points - 1 ? \"+\" : \"\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        \\\\ \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}`;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"points-slider\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Gauss Points = {points}\r\n                                        </Typography>\r\n                                        <Box id=\"points-slider\">\r\n                                            <Slider\r\n                                                orientation=\"horizontal\"\r\n                                                onChange={(event, value) => { setPoints(parseInt(value)) }}\r\n                                                defaultValue={points}\r\n                                                aria-labelledby=\"discrete-slider-small-steps\"\r\n                                                step={1}\r\n                                                marks={[{ value: 2, label: 2 }, { value: 6, label: 6 }]}\r\n                                                min={2}\r\n                                                max={6}\r\n                                                valueLabelDisplay=\"auto\"\r\n                                            />\r\n                                        </Box>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"point-table\">\r\n                                        <Slide direction=\"up\" triggerOnce>\r\n                                            <Table className={styleClasses.table} aria-label=\"gauss point table\">\r\n                                                <TableHead>\r\n                                                    <TableRow>\r\n                                                        <TableCell>Coefficient</TableCell>\r\n                                                        <TableCell>Gauss point</TableCell>\r\n                                                    </TableRow>\r\n                                                </TableHead>\r\n                                                <TableBody>\r\n                                                    {[...Array(points).keys()].map((i) => (\r\n                                                        <TableRow key={i}>\r\n                                                            <TableCell component=\"th\" scope=\"row\"> {`C${i + 1} = ${formatLatex(p.c[i])}`} </TableCell>\r\n                                                            <TableCell> {`t${i + 1} = ${formatLatex(p.x[i])}`} </TableCell>\r\n                                                        </TableRow>\r\n                                                    ))}\r\n                                                </TableBody>\r\n                                            </Table>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralQuadrature;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Trapezoidal.js",["307"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".subIntervals-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the number of subintervals, N.\",\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction IntegralTrapezoidal({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\left(x-3\\right)^{3}+2\\left(x-3\\right)^{2}-1`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(1);\r\n    const [upperX, setUpperX] = useState(4);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (isNaN(lowerX)) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (isNaN(upperX)) {\r\n        intervalError = true;\r\n        upperXErrorText = \"x value cannot be empty!\";\r\n    }\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n\r\n    // Subintervals\r\n    const [subIntervals, setSubIntervals] = useState(10);\r\n    let subIntervalsError = false;\r\n    let subIntervalsErrorText = \"\";\r\n    if (isNaN(subIntervals) || !Number.isInteger(subIntervals) || subIntervals <= 0) {\r\n        subIntervalsError = true;\r\n        subIntervalsErrorText = \"Subintervals must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || subIntervalsError;\r\n\r\n    // Solve\r\n    let latexContent, graphCallback;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        const width = (upperX - lowerX) / subIntervals;\r\n        let integralResult = 0;\r\n        let results = [];\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            const x = lowerX + i * width;\r\n            let f = functionValue.evaluate({ x: x });\r\n            if (i === 0 || i === subIntervals) {\r\n                integralResult += f;\r\n                results.push(f);\r\n            }\r\n            else {\r\n                integralResult += 2 * f;\r\n                results.push(2 * f);\r\n            }\r\n        }\r\n        integralResult *= width / 2;\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ h &=& \\frac{ x_{upper} - x_{lower} }{N}\r\n        \\\\   &=& ${formatLatex(width)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ x_i = x_{lower} + i \\cdot h\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\int_{${lowerX}}^{${upperX}} f(x) dx &=& \\frac{h}{2} [f(x_0) + 2 \\sum_{i=1}^{${subIntervals - 1}} f(x_i) + f(x_{${subIntervals}})]\r\n        \\\\`;\r\n        latexContent += String.raw`\r\n        \\\\ &=& ${formatLatex(width / 2)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${i === 0 || i === subIntervals ? \"\" : \"2\"}f(${formatLatex(lowerX + i * width)}) ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(width / 2)} [`;\r\n        for (let i = 0; i <= subIntervals; i++) {\r\n            latexContent += String.raw`${formatLatex(results[i])} ${i === subIntervals ? \"\" : \"+\"}`;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(integralResult)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: \"f(x)=\" + functionLatex });\r\n            calculator.current.setExpression({ id: 'a', latex: \"a=\" + lowerX });\r\n            calculator.current.setExpression({ id: 'b', latex: \"b=\" + upperX });\r\n            calculator.current.setExpression({ id: 'N', latex: \"N=\" + subIntervals });\r\n            calculator.current.setExpression({ id: 'L', latex: String.raw`L=\\left[a,\\ a+\\frac{\\left(b-a\\right)}{N},\\ a+\\frac{2\\left(b-a\\right)}{N},...,a+\\frac{\\left(N-1\\right)\\left(b-a\\right)}{N}\\right]` });\r\n            calculator.current.setExpression({ id: 'R', latex: String.raw`R=\\left[a+\\frac{\\left(b-a\\right)}{N},a+\\frac{2\\left(b-a\\right)}{N},\\ ...,b\\right]` });\r\n            calculator.current.setExpression({ id: 'M', latex: String.raw`M=\\frac{\\left(f\\left(R\\right)-f\\left(L\\right)\\right)}{R-L}` });\r\n            calculator.current.setExpression({ id: 'm', latex: String.raw`m=\\left[a+\\frac{.5\\left(b-a\\right)}{N},a+\\frac{3}{2}\\cdot\\frac{\\left(b-a\\right)}{N},...,b-\\frac{\\left(\\frac{1}{2}\\right)\\left(b-a\\right)}{N}\\right]` });\r\n            calculator.current.setExpression({ id: 'x', color: Desmos.Colors.BLACK, latex: String.raw`x=L\\left\\{\\min\\left(0,f\\left(L\\right)\\right)<y<\\max\\left(0,f\\left(L\\right)\\right)\\right\\}` });\r\n            calculator.current.setExpression({ id: 'positive', color: Desmos.Colors.GREEN, latex: String.raw`0\\le y\\le M\\left(x-L\\right)+f\\left(L\\right)\\left\\{L\\le x\\le R\\right\\}` });\r\n            calculator.current.setExpression({ id: 'negative', color: Desmos.Colors.RED, latex: String.raw`0\\ge y\\ge M\\left(x-L\\right)+f\\left(L\\right)\\left\\{L\\le x\\le R\\right\\}` });\r\n            /*\r\n            for (let i = 0; i <= subIntervals; i++) {\r\n                const x = lowerX + i * width;\r\n                let v = results[i];\r\n                if (i > 0 && i < subIntervals) {\r\n                    v /= 2;\r\n                }\r\n                calculator.current.setExpression({ id: i, color: Desmos.Colors.BLACK, pointStyle: Desmos.Styles.POINT, label: i + 1, showLabel: subIntervals < 20, latex: String.raw`(${x}, ${v})`});\r\n            }\r\n            */\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"subIntervals-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Subintervals, N:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setSubIntervals(parseInt(event.target.value))}\r\n                                            error={subIntervalsError}\r\n                                            label={subIntervalsError ? \"Error\" : \"\"}\r\n                                            defaultValue={subIntervals.toString()}\r\n                                            helperText={subIntervalsErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError}\r\n                                            label={intervalError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                    <Grid xs item className=\"graph-button\">\r\n\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default IntegralTrapezoidal;","F:\\numerical-methods-js\\src\\components\\methods\\integral\\Midpoint.js",["308","309","310","311","312","313","314","315"],"F:\\numerical-methods-js\\src\\components\\methods\\differential\\Multivariable.js",["316"],"import React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport { Zoom } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport haroldImage from '../../../images/harold.jpg';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".main\",\r\n        title: \"Incomplete!\",\r\n        content:\r\n            \"Nothing to see here.\",\r\n        disableBeacon: true,\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(2)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n    harold: {\r\n        height: \"auto\",\r\n        width: \"30vw\",\r\n        \"border-radius\": \"3em\",\r\n        \"box-shadow\": \"0px 8px 6px rgba(34,34,34,0.6)\",\r\n    }\r\n}));\r\n\r\nfunction DiffMultivariable({ methodName }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography className=\"main\" variant=\"body1\">\r\n                            Incomplete! Nothing to see here.\r\n                        </Typography>\r\n                        <Divider />\r\n                        <img className={styleClasses.harold} src={haroldImage} alt=\"Hide the Pain Harold\" />\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default DiffMultivariable;","F:\\numerical-methods-js\\src\\components\\methods\\differential\\Finite.js",["317","318"],"import { isValidMath, mathjsKeywords, mathjsToLatex, formatLatex } from \"../../utils\";\r\nimport { getBinomialCoefficient } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect, useMemo } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".x-input\",\r\n        title: \"X value\",\r\n        content:\r\n            \"Specify the value of x at which to evaluate.\",\r\n    },\r\n    {\r\n        target: \".order-input\",\r\n        title: \"Order\",\r\n        content:\r\n            \"Specify the differential order to evaluate.\",\r\n    },\r\n    {\r\n        target: \".stepSize-input\",\r\n        title: \"Step Size\",\r\n        content:\r\n            \"Specify the step size.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction DiffFinite({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`3x^5+2x^3-8`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n        functionValue.evaluate({ x: 0 });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // x values\r\n    const [xInput, setXInput] = useState(1.5);\r\n    let xInputError = false;\r\n    let xInputErrorText = \"\";\r\n    if (isNaN(xInput)) {\r\n        xInputError = true;\r\n        xInputErrorText = \"x value cannot be empty!\";\r\n    }\r\n\r\n    // Order\r\n    const [order, setOrder] = useState(4);\r\n    let orderError = false;\r\n    let orderErrorText = \"\";\r\n    if (isNaN(order) || !Number.isInteger(order) || order <= 0) {\r\n        orderError = true;\r\n        orderErrorText = \"Order must be a positive integer!\";\r\n    }\r\n    else if (order > 14) {\r\n        orderError = true;\r\n        orderErrorText = \"Order too high! Due to the factorial nature of the finite difference, the browser will lag or crash if it attempts to compute this.\";\r\n    }\r\n\r\n    // Step Size\r\n    const [stepSize, setStepSize] = useState(0.01);\r\n    let stepSizeError = false;\r\n    let stepSizeErrorText = \"\";\r\n    if (isNaN(stepSize) || stepSize <= 0) {\r\n        stepSizeError = true;\r\n        stepSizeErrorText = \"Step size cannot be negative or zero!\";\r\n    }\r\n\r\n    let hasError = functionError || xInputError || orderError || stepSizeError;\r\n\r\n    // Solve\r\n    let latexContent;\r\n    let solve = false;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let derivValue = derivative(functionValue, 'x');\r\n        for (let i = 0; i < order - 1; i++) {\r\n            derivValue = derivative(derivValue, 'x');\r\n        }\r\n        const evaluateFunction = (forward, offset) => {\r\n            const step = offset * stepSize;\r\n            return forward ? functionValue.evaluate({ x: xInput + step }) : functionValue.evaluate({ x: xInput - step });\r\n        }\r\n\r\n        const denominator = Math.pow(stepSize, order);\r\n        let forwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n        }\r\n        let backwardDiff = 0;\r\n        for (let i = 0; i <= order; i++) {\r\n            backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n        }\r\n        let centralDiff = 0;\r\n        if (order > 1) {\r\n            for (let i = 0; i <= order; i++) {\r\n                centralDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(true, order / 2 - i) / denominator;\r\n            }\r\n        }\r\n        else {\r\n            // To adhere to lecturer's annoying convention\r\n            centralDiff = (evaluateFunction(true, 1) - evaluateFunction(false, 1)) / (2 * stepSize);\r\n        }\r\n\r\n        const correctDerivative = derivValue.evaluate({ x: xInput });\r\n\r\n        const forwardError = Math.abs(correctDerivative - forwardDiff);\r\n        const backwardError = Math.abs(correctDerivative - backwardDiff);\r\n        const centralError = Math.abs(correctDerivative - centralDiff);\r\n\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ f^{${order}}(x) &=& ${mathjsToLatex(derivValue)}\r\n        \\\\                 &=& ${formatLatex(correctDerivative)}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Forward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{${order}-i} \\dbinom{${order}}{i} f(x+ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            //forwardDiff += Math.pow(-1, order - i) * getBinomialCoefficient(order, i) * evaluateFunction(true, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, order - i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, i))}) ${i === order ? '' : '+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(forwardDiff)}\r\n        \\end{array}\r\n        `;\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Backward difference} &=& \\frac{1}{${order === 1 ? \"h\" : `h^{${order}}`}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x-ih) \\right]\r\n        \\\\\r\n        \\\\ &=& \\frac{1}{${order === 1 ? formatLatex(stepSize) : `${formatLatex(stepSize)}^{${order}}`}} [\r\n        `;\r\n        for (let i = 0; i <= order; i++) {\r\n            // backwardDiff += Math.pow(-1, i) * getBinomialCoefficient(order, i) * evaluateFunction(false, i) / denominator;\r\n            latexContent += String.raw`\r\n            (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(false, i))}) ${i === order ? '' : '+'}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        ]\r\n        \\\\\r\n        \\\\ &=& ${formatLatex(backwardDiff)}\r\n        \\end{array}\r\n        `;\r\n\r\n        if (order === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{2h} [f(x+h) - f(x-h)]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(2 * stepSize)}} [${formatLatex(evaluateFunction(true, 1))} - ${formatLatex(evaluateFunction(false, 1))} ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Central difference} &=& \\frac{1}{h^{${order}}} \\sum_{i=0}^{${order}} \\left[ (-1)^{i} \\dbinom{${order}}{i} f(x+(\\frac{n}{2}-i)h) \\right]\r\n            \\\\\r\n            \\\\ &=& \\frac{1}{${formatLatex(stepSize)}^{${order}}} [\r\n            `;\r\n            for (let i = 0; i <= order; i++) {\r\n                latexContent += String.raw`\r\n                (${Math.pow(-1, i)})(${getBinomialCoefficient(order, i)})(${formatLatex(evaluateFunction(true, order / 2 - i))}) ${i === order ? '' : '+'}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            ]\r\n            \\\\\r\n            \\\\ &=& ${formatLatex(centralDiff)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Percentage Error} &=& |Actual - Estimate|\r\n        \\\\\r\n        \\\\ E_{Forward} &=& ${formatLatex(forwardError)}\r\n        \\\\ E_{Backward} &=& ${formatLatex(backwardError)}\r\n        \\\\ E_{Central} &=& ${formatLatex(centralError)}\r\n        \\end{array}\\end{array}\r\n        `;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"x-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            x:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setXInput(parseFloat(event.target.value))}\r\n                                            error={xInputError}\r\n                                            label={xInputError ? \"Error\" : \"\"}\r\n                                            defaultValue={xInput.toString()}\r\n                                            helperText={xInputErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"order-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Order:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setOrder(parseInt(event.target.value))}\r\n                                            error={orderError}\r\n                                            label={orderError ? \"Error\" : \"\"}\r\n                                            defaultValue={order.toString()}\r\n                                            helperText={orderErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"stepSize-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Step size, h:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setStepSize(parseFloat(event.target.value))}\r\n                                            error={stepSizeError}\r\n                                            label={stepSizeError ? \"Error\" : \"\"}\r\n                                            defaultValue={stepSize.toString()}\r\n                                            helperText={stepSizeErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve &&\r\n                            <Container className={styleClasses.container}>\r\n                                <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid xs item className=\"step-math\">\r\n                                        <Slide direction=\"left\" triggerOnce>\r\n                                            <Card className={styleClasses.card}>\r\n                                                <CardContent className={styleClasses.cardContent}>\r\n                                                    <TeX math={latexContent} block />\r\n                                                </CardContent>\r\n                                            </Card>\r\n                                        </Slide>\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Container>\r\n                        }\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default DiffFinite;","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\Discs.js",["319","320","321","322","323","324"],"F:\\numerical-methods-js\\src\\components\\methods\\optimisation\\Gradient.js",["325","326"],"import { isValidMath, mathjsToLatex, formatLatex, mathjsKeywords } from \"../../utils\";\r\nimport { initialMatrix17, generateGridCallback, createNewColumn, gridTo2DArray, matrixToLatex } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative, simplify, subtract, norm } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function with multiple variables. Variable names must contain only one alphabet, such as x, y, z etc.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".variables-display\",\r\n        title: \"Variables\",\r\n        content:\r\n            \"The variables of the function are displayed here.\",\r\n    },\r\n    {\r\n        target: \".vector-input\",\r\n        title: \"Initial Vector\",\r\n        content:\r\n            \"Specify the initial values of the variables here.\",\r\n    },\r\n    {\r\n        target: \".initialRoot-input\",\r\n        title: \"Initial Root Guess\",\r\n        content:\r\n            \"Specify the initial root guess when finding the root.\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold when finding the root.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the gradient method.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OptiGradient({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n    // 2xy+2x-x^2-2y^2\r\n    // 2\\left(x+y\\right)^2 + \\left(x-y\\right)^2 + 3x + 2y\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`2\\left(x+y\\right)^2 + \\left(x-y\\right)^2 + 3x + 2y`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionNode;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    let variables = new Set(); // Unique set of variables\r\n    try {\r\n        functionNode = parse(functionText);\r\n        functionNode.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name.length > 1) {\r\n                    throw \"variableName\";\r\n                }\r\n                if (node.name === 't') {\r\n                    throw \"noTVariableName\";\r\n                }\r\n                variables.add(node.name);\r\n            }\r\n        });\r\n        variables = [...variables].sort(); // Alphabetical order\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Variable names must contain only one alphabet! x, y, z etc\" : \"Invalid equation!\";\r\n        functionErrorText = e === \"noTVariableName\" ? \"Variable name t is not allowed!\" : functionErrorText;\r\n    }\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n\r\n    let [vectorState, setVectorState] = useState(initialMatrix17);\r\n\r\n    let initialVector = { columns: [], rows: [{}] };\r\n    const addVariableToVector = (variableName, variableValue) => {\r\n        const columns = initialVector.columns;\r\n        const rows = initialVector.rows;\r\n        columns.push(createNewColumn(columns.length, variableName));\r\n        let colName = `col_${columns.length}`;\r\n        rows[0][colName] = vectorState.rows[0].hasOwnProperty(colName) ? vectorState.rows[0][colName] : variableValue;\r\n    }\r\n    for (let v of variables) {\r\n        addVariableToVector(v, 0);\r\n    }\r\n    vectorState = initialVector;\r\n\r\n    // Initial Root\r\n    const [initialRoot, setInitialRoot] = useState(0.1);\r\n    let initialRootError = false;\r\n    let initialRootErrorText = \"\";\r\n    if (isNaN(initialRoot)) {\r\n        initialRootError = true;\r\n        initialRootErrorText = \"Initial root guess must be a valid number!\";\r\n    }\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.005);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (errorThreshold < 0 || isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative or zero!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(5);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    let hasError = functionError || initialRootError || thresholdError || iterError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let derivNodes = {};\r\n    let results = [];\r\n\r\n    if (isValidMath(functionNode) && !hasError && variables.length > 0) {\r\n        solve = true;\r\n        for (let v of variables) {\r\n            derivNodes[v] = derivative(functionText, v);\r\n        }\r\n        for (let iter = 0; iter < iterations; iter++) {\r\n            const previousVector = (iter === 0) ? gridTo2DArray(vectorState.rows)[0] : results[iter - 1].newVector;\r\n            let derivScope = {};\r\n            variables.forEach((element, index) => {\r\n                derivScope[element] = previousVector[index];\r\n            });\r\n            let derivResult = [];\r\n            for (let v of variables) {\r\n                derivResult.push(derivNodes[v].evaluate(derivScope));\r\n            }\r\n            let directionNodes = {};\r\n            variables.forEach((element, index) => {\r\n                directionNodes[element] = simplify(parse(String.raw`${previousVector[index]} + t*(${derivResult[index]})`));\r\n            });\r\n            const transformedFunction = functionNode.transform(function (node, path, parent) {\r\n                if (node.isSymbolNode && !mathjsKeywords.includes(node.name)) {\r\n                    return directionNodes[node.name];\r\n                }\r\n                else {\r\n                    return node;\r\n                }\r\n            });\r\n            const simplifiedFunction = simplify(transformedFunction);\r\n            const simplifiedFunctionDeriv = derivative(simplifiedFunction, 't');\r\n            const simplifiedFunctionDeriv2 = derivative(simplifiedFunctionDeriv, 't');\r\n            let rootT = initialRoot;\r\n            let newtonIter = 1;\r\n            while (true) {\r\n                const oldT = rootT;\r\n                const funcValue = simplifiedFunctionDeriv.evaluate({ t: rootT });\r\n                const derivValue = simplifiedFunctionDeriv2.evaluate({ t: rootT });\r\n                rootT = rootT - funcValue / derivValue;\r\n                if (!isFinite(rootT)) {\r\n                    break;\r\n                }\r\n                let errorX = Math.abs(rootT - oldT);\r\n                if (errorX < errorThreshold || newtonIter > 50) {\r\n                    break;\r\n                }\r\n                newtonIter++;\r\n            }\r\n            const newVector = variables.map((element, index) => {\r\n                return directionNodes[element].evaluate({ t: rootT });\r\n            });\r\n            let functionScope = {};\r\n            variables.forEach((element, index) => {\r\n                functionScope[element] = newVector[index];\r\n            });\r\n            const newFunctionResult = functionNode.evaluate(functionScope)\r\n            const errorMagnitude = norm(subtract(newVector, previousVector), 2);\r\n            results.push({\r\n                previousVector,\r\n                derivResult,\r\n                directionNodes,\r\n                transformedFunction,\r\n                simplifiedFunction,\r\n                simplifiedFunctionDeriv,\r\n                newtonIter,\r\n                rootT,\r\n                newVector,\r\n                newFunctionResult,\r\n                errorMagnitude,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionNode, variables, derivNodes, initialRoot, errorThreshold, iterations, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            Supports as many variables as possible (x, y, z, a, b, c etc).\r\n                            <br />\r\n                            However, the more variables, the longer the computation time.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                            }}\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"variables-display\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Variables:\r\n                                        </Typography>\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                        <Collapse in={!functionError}>\r\n                                            {!functionError && <Fade triggerOnce>\r\n                                                <Typography variant=\"h6\">\r\n                                                    {[...variables].join(', ')}\r\n                                                </Typography>\r\n                                            </Fade>}\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"vector-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                <Grid xs item>\r\n                                    <Typography variant=\"h6\">\r\n                                        Initial Point, <TeX math={String.raw`X^{(0)}`} />:\r\n                                    </Typography>\r\n                                </Grid>\r\n                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                        <ReactDataGrid\r\n                                            columns={vectorState.columns}\r\n                                            rowGetter={i => vectorState.rows[i]}\r\n                                            rowsCount={vectorState.rows.length}\r\n                                            onGridRowsUpdated={generateGridCallback(vectorState, setVectorState)}\r\n                                            enableCellSelect={true}\r\n                                            minColumnWidth={columnWidth}\r\n                                            minWidth={columnWidth * vectorState.columns.length + widthPadding}\r\n                                            rowHeight={rowHeight}\r\n                                            minHeight={rowHeight * (vectorState.rows.length + 1) + heightPadding}\r\n                                        />\r\n                                    </Grid>\r\n                                </Grid>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"initialRoot-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial root guess, <TeX math={String.raw`t_0`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setInitialRoot(parseFloat(event.target.value))}\r\n                                            error={initialRootError}\r\n                                            label={initialRootError ? \"Error\" : \"\"}\r\n                                            defaultValue={initialRoot.toString()}\r\n                                            helperText={initialRootErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"errorThreshold-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Error threshold for finding <TeX math={String.raw`t^*`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setErrorThreshold(parseFloat(event.target.value))}\r\n                                            error={thresholdError}\r\n                                            label={thresholdError ? \"Error\" : \"\"}\r\n                                            defaultValue={errorThreshold.toString()}\r\n                                            helperText={thresholdErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations of gradient method:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ smallScreen, params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    const results = params.results;\r\n    const variables = params.variables;\r\n    const currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ f(${variables.join(\",\")}) = ${mathjsToLatex(params.functionNode)}\r\n        \\\\\r\n        \\\\ X^{(${currentIteration - 1})} = ${matrixToLatex([currentResult.previousVector])}\r\n        \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}`;\r\n\r\n        variables.forEach((v, index) => {\r\n            latexContent += String.raw`\r\n            \\\\ f_${v} &=& ${mathjsToLatex(params.derivNodes[v])}\r\n            \\\\ f_${v}(X^{(${currentIteration - 1})}) &=& ${formatLatex(currentResult.derivResult[index])}\r\n            \\\\ \r\n            `;\r\n        });\r\n\r\n        latexContent += String.raw`\r\n        \\\\ \\nabla f &=& ${matrixToLatex([currentResult.derivResult])}\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ X^{(${currentIteration})} &=& X^{(${currentIteration - 1})} + t \\cdot \\nabla f\r\n        \\\\\r\n        \\\\                           &=& ${matrixToLatex([currentResult.previousVector])} + t \\cdot ${matrixToLatex([currentResult.derivResult])}\r\n        \\\\\r\n        \\\\                           &=& \\left[\\begin{matrix}\r\n        `;\r\n        variables.forEach((v, index) => {\r\n            latexContent += String.raw`\r\n            ${mathjsToLatex(currentResult.directionNodes[v])}\r\n            `;\r\n            if (index !== variables.length - 1) {\r\n                latexContent += ',&';\r\n            }\r\n        });\r\n        latexContent += String.raw`\r\n        \\end{matrix}\\right]\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ f(X^{(${currentIteration})}) &=& ${mathjsToLatex(currentResult.transformedFunction)}\r\n        \\\\\r\n        \\\\                              &=& ${mathjsToLatex(currentResult.simplifiedFunction)}\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        \\\\ \\hline\r\n        \\begin{array}{lcl}\r\n        \\\\ \\frac{df(X^{(${currentIteration})})}{dt} = 0\r\n        \\\\\r\n        \\\\ ${mathjsToLatex(currentResult.simplifiedFunctionDeriv)} &=& 0\r\n        \\\\ \\end{array}\r\n        \\\\\r\n        `\r\n        if (!isFinite(currentResult.rootT)) {\r\n            latexContent += String.raw`\r\n            \\\\ \\text{Given that }\\frac{df(X^{(${currentIteration})})}{dt} = 0 \\text{ has no roots, the gradient method cannot proceed.}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\ \\text{Using the Newton-Rhapson method}\r\n            \\\\ \\text{with initial guess } t_0 = ${params.initialRoot}\r\n            \\\\ \\text{and error threshold of ${params.errorThreshold},}\r\n            \\\\ \\text{the solution to } \\frac{df(X^{(${currentIteration})})}{dt} = 0 \\text{ after ${currentResult.newtonIter} iterations is:}\r\n            \\\\\r\n            \\\\ t^* = ${formatLatex(currentResult.rootT)}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ X^{(${currentIteration})} &=& X^{(${currentIteration - 1})} + t^* \\cdot \\nabla f\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex([currentResult.previousVector])} + ${formatLatex(currentResult.rootT)} \\cdot ${matrixToLatex([currentResult.derivResult])}\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex([currentResult.newVector])}\r\n            \\\\\r\n            \\\\ f(X^{(${currentIteration})}) &=& ${formatLatex(currentResult.newFunctionResult)}\r\n            \\\\\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ Error &=& \\lVert X^{(${currentIteration})} - X^{(${currentIteration - 1})} \\rVert\r\n            \\\\       &=& \\lVert ${matrixToLatex([currentResult.newVector])} - ${matrixToLatex([currentResult.previousVector])} \\rVert\r\n            \\\\       &=& ${formatLatex(currentResult.errorMagnitude)}\r\n            \\end{array}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        \\end{array}\r\n        `\r\n    }\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iteration {currentIteration}:\r\n                                    </Typography>\r\n                                    <TeX math={latexContent} block />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default OptiGradient;","F:\\numerical-methods-js\\src\\components\\methods\\optimisation\\GoldenSearch.js",["327","328","329"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".interval-input\",\r\n        title: \"Interval\",\r\n        content:\r\n            \"Select the lower and upper bounds of x\",\r\n    },\r\n    {\r\n        target: \".intervalThreshold-input\",\r\n        title: \"Interval Threshold\",\r\n        content:\r\n            \"Specify the minimum interval threshold\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction OptiGoldenSearch({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Function\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`3+6x-4x^2`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Interval\r\n    const [lowerX, setLowerX] = useState(-1);\r\n    const [upperX, setUpperX] = useState(2);\r\n    let intervalError = false;\r\n    let lowerXErrorText = \"\";\r\n    let upperXErrorText = \"\";\r\n    if (lowerX >= upperX) {\r\n        intervalError = true;\r\n        lowerXErrorText = \"Lower x must be lower than upper x!\";\r\n        upperXErrorText = \"Upper x must be higher than lower x!\";\r\n    }\r\n    let lowerXError = false;\r\n    if (isNaN(lowerX)) {\r\n        lowerXError = true;\r\n        lowerXErrorText = \"Lower x must be a number!\";\r\n    }\r\n    let upperXError = false;\r\n    if (isNaN(upperX)) {\r\n        upperXError = true;\r\n        upperXErrorText = \"Upper x must be a number!\";\r\n    }\r\n\r\n    // Interval threshold\r\n    const [intervalThreshold, setIntervalThreshold] = useState(0.25);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(intervalThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    if (intervalThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = functionError || intervalError || lowerXError || upperXError || thresholdError;\r\n\r\n    // Solve\r\n    const goldenRatio = (Math.sqrt(5) - 1) / 2;\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    let results = [];\r\n    let iterations = 1;\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        let i = 0;\r\n        while (true) {\r\n            let oldLowerX = (i === 0) ? lowerX : results[i - 1].newLowerX;\r\n            let oldUpperX = (i === 0) ? upperX : results[i - 1].newUpperX;\r\n            const d = goldenRatio * (oldUpperX - oldLowerX);\r\n            let aX = oldUpperX - d;\r\n            let bX = oldLowerX + d;\r\n            let newLowerX = aX;\r\n            let newUpperX = bX;\r\n            let lowerFuncResult, upperFuncResult;\r\n            try {\r\n                lowerFuncResult = functionValue.evaluate({ x: aX });\r\n                upperFuncResult = functionValue.evaluate({ x: bX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n            if (lowerFuncResult > upperFuncResult) {\r\n                newLowerX = oldLowerX;\r\n            }\r\n            else if (lowerFuncResult < upperFuncResult) {\r\n                newUpperX = oldUpperX;\r\n            }\r\n            // Check if interval is lower than threshold\r\n            const interval = Math.abs(newUpperX - newLowerX);\r\n\r\n            results.push({\r\n                oldLowerX,\r\n                newLowerX,\r\n                oldUpperX,\r\n                newUpperX,\r\n                d,\r\n                aX,\r\n                bX,\r\n                lowerFuncResult,\r\n                upperFuncResult,\r\n                interval,\r\n            });\r\n            i++;\r\n            if (i > 1000) {\r\n                exceedIterError = true;\r\n                exceedIterErrorText = \"Exceeded 1000 iterations!\";\r\n                break;\r\n            }\r\n            if (interval < intervalThreshold) {\r\n                break;\r\n            }\r\n        }\r\n        iterations = i;\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, intervalThreshold, goldenRatio, iterations, exceedIterError, exceedIterErrorText, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, f(x):\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid className=\"interval-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Lower x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setLowerX(parseFloat(event.target.value))}\r\n                                            error={intervalError || lowerXError}\r\n                                            label={intervalError || lowerXError ? \"Error\" : \"\"}\r\n                                            defaultValue={lowerX.toString()}\r\n                                            helperText={lowerXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Upper x value:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setUpperX(parseFloat(event.target.value))}\r\n                                            error={intervalError || upperXError}\r\n                                            label={intervalError || upperXError ? \"Error\" : \"\"}\r\n                                            defaultValue={upperX.toString()}\r\n                                            helperText={upperXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"intervalThreshold-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Interval threshold:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIntervalThreshold(parseFloat(event.target.value))}\r\n                                            error={thresholdError}\r\n                                            label={thresholdError ? \"Error\" : \"\"}\r\n                                            defaultValue={intervalThreshold.toString()}\r\n                                            helperText={thresholdErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let oldLowerXLatex = String.raw`x_{lower_{${currentIteration - 1}}}`;\r\n        let oldUpperXLatex = String.raw`x_{upper_{${currentIteration - 1}}}`;\r\n        let newLowerXLatex = String.raw`x_{lower_{${currentIteration}}}`;\r\n        let newUpperXLatex = String.raw`x_{upper_{${currentIteration}}}`;\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${oldLowerXLatex} &=& ${formatLatex(currentResult.oldLowerX)}\r\n        \\\\ ${oldUpperXLatex} &=& ${formatLatex(currentResult.oldUpperX)}\r\n        \\\\\r\n        \\\\ d &=& R (${oldUpperXLatex} - ${oldLowerXLatex})\r\n        \\\\   &=& ${formatLatex(currentResult.d)}\r\n        \\\\\r\n        \\\\ x_a &=& ${oldUpperXLatex} - d\r\n        \\\\     &=& ${formatLatex(currentResult.aX)}\r\n        \\\\ x_b &=& ${oldLowerXLatex} + d\r\n        \\\\     &=& ${formatLatex(currentResult.bX)}\r\n        \\\\\r\n        \\\\ f(x_a) &=& ${formatLatex(currentResult.lowerFuncResult)}\r\n        \\\\ f(x_b) &=& ${formatLatex(currentResult.upperFuncResult)}\r\n        \\\\\r\n        \\\\\r\n        `;\r\n        if (currentResult.lowerFuncResult > currentResult.upperFuncResult) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(x_a) > f(x_b),\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& ${oldLowerXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& x_b\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else if (currentResult.lowerFuncResult < currentResult.upperFuncResult) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(x_a) < f(x_b),\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& x_a\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& ${oldUpperXLatex}\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\ \\hline\r\n            \\\\ \\text{Given that } f(x_a) = f(x_b),\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${newLowerXLatex} &=& x_a\r\n            \\\\                   &=& ${formatLatex(currentResult.newLowerX)}\r\n            \\\\ ${newUpperXLatex} &=& x_b\r\n            \\\\                   &=& ${formatLatex(currentResult.newUpperX)}\r\n            `;\r\n        }\r\n        latexContent += String.raw`\r\n        \\\\\r\n        \\\\ \\text{Uncertainty Interval} &=& |${newUpperXLatex} - ${newLowerXLatex}|\r\n        \\\\                             &=& |${formatLatex(currentResult.interval)}|\r\n        `;\r\n        if (currentIteration === params.iterations) {\r\n            latexContent += String.raw`\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Stop searching because:}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ \\text{Uncertainty Interval} &<& \\text{Interval Threshold}\r\n            \\\\ ${formatLatex(currentResult.interval)} &<& ${formatLatex(params.intervalThreshold)}\r\n            `;\r\n        }\r\n\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'x_a', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"x_a\", showLabel: true, latex:\r\n                    `(${currentResult.aX}, ${currentResult.lowerFuncResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'x_b', color: Desmos.Colors.GREEN, pointStyle: Desmos.Styles.POINT, label: \"x_b\", showLabel: true, latex:\r\n                    `(${currentResult.bX}, ${currentResult.upperFuncResult})`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n\r\n                    <Grid container xs item direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                        <Grid xs item className=\"iteration-slider\">\r\n                            <Slide direction=\"left\" triggerOnce>\r\n                                <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                    <Slider\r\n                                        orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                        onChangeCommitted={(event, value) => setCurrentIteration(value)}\r\n                                        defaultValue={1}\r\n                                        aria-labelledby=\"discrete-slider-small-steps\"\r\n                                        step={1}\r\n                                        marks\r\n                                        min={1}\r\n                                        max={params.iterations}\r\n                                        valueLabelDisplay=\"on\"\r\n                                    />\r\n\r\n                                </Box>\r\n                            </Slide>\r\n                        </Grid>\r\n                        <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"step-math\">\r\n                                <Zoom duration={500} triggerOnce>\r\n                                    <Card className={styleClasses.card}>\r\n                                        <CardContent className={styleClasses.cardContent}>\r\n                                            <Typography variant=\"h6\">\r\n                                                Iteration {currentIteration}:\r\n                                            </Typography>\r\n                                            <TeX math={latexContent} block />\r\n                                        </CardContent>\r\n                                    </Card>\r\n                                </Zoom>\r\n                            </Grid>\r\n                        </Grid>\r\n                        <Grid xs item className=\"graph-button\">\r\n\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\nexport default OptiGoldenSearch;","F:\\numerical-methods-js\\src\\components\\methods\\fourier\\FFT.js",["330","331","332","333","334"],"F:\\numerical-methods-js\\src\\components\\methods\\eigen\\ShiftedPower.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\eigen\\Power.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\linear\\PenroseInverse.js",["335"],"import { formatMatrixLatex } from \"../../utils\";\r\nimport { initialMatrix6 as initialMatrix, generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, matrixToLatex, cloneArray } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { transpose, multiply, identity } from 'mathjs';\r\nimport { Matrix as MLMatrix, EigenvalueDecomposition as MLEigen } from 'ml-matrix';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport { Zoom } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".matrix-col-input\",\r\n        title: \"Column\",\r\n        content:\r\n            \"Add/Remove columns\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-row-input\",\r\n        title: \"Row\",\r\n        content:\r\n            \"Add/Remove rows\",\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n            \"Specify the matrix here.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearPenrose({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const columnCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n            }\r\n            setGridState({ columns, rows });\r\n        };\r\n    }\r\n    const rowCallback = (add) => {\r\n        return () => {\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                rows.push(createNewRow(gridState.columns.length));\r\n            }\r\n            else {\r\n                if (rows.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n            }\r\n            setGridState({ ...gridState, rows });\r\n        };\r\n    }\r\n\r\n    // Solve\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const rowLength = gridState.rows.length; // row dimension\r\n    const colLength = gridState.columns.length; // column dimension\r\n\r\n    /*\r\n    const multiplyTranspose = multiply(transpose(originalMatrix), originalMatrix); // AT*A\r\n    const multiplyTransposeEigen = eigs(multiplyTranspose);\r\n    const multiplyTransposeSingularValues = multiplyTransposeEigen.values.slice().reverse().map((v) => Math.sqrt(v));\r\n    const transposeMultiply = multiply(originalMatrix, transpose(originalMatrix)); // A*AT\r\n    const transposeMultiplyEigen = eigs(transposeMultiply);\r\n    const transposeMultiplySingularValues = transposeMultiplyEigen.values.slice().reverse().map((v) => Math.sqrt(v));\r\n\r\n    let rightUnitaryT = transpose(multiplyTransposeEigen.vectors).reverse();\r\n    let rightUnitary = transpose(rightUnitaryT);\r\n\r\n    let leftUnitaryT = transpose(transposeMultiplyEigen.vectors).reverse();\r\n    let leftUnitary = transpose(leftUnitaryT);\r\n    */\r\n\r\n    const multiplyTranspose = multiply(originalMatrix, transpose(originalMatrix)); // A*AT\r\n    const multiplyTransposeEigen = new MLEigen(new MLMatrix(multiplyTranspose));\r\n    const multiplyTransposeEigenMatrix = Array.from(multiplyTransposeEigen.eigenvectorMatrix.data.map((v) => Array.from(v)));\r\n    const multiplyTransposeSingularValues = multiplyTransposeEigen.realEigenvalues.slice().reverse().map((v) => Math.sqrt(v));\r\n\r\n    const transposeMultiply = multiply(transpose(originalMatrix), originalMatrix); // AT*A\r\n    const transposeMultiplyEigen = new MLEigen(new MLMatrix(transposeMultiply));\r\n    const transposeMultiplyEigenMatrix = Array.from(transposeMultiplyEigen.eigenvectorMatrix.data.map((v) => Array.from(v)));\r\n    const transposeMultiplyEigenValues = transposeMultiplyEigen.realEigenvalues.slice().reverse();\r\n    const transposeMultiplySingularValues = transposeMultiplyEigen.realEigenvalues.slice().reverse().map((v) => Math.sqrt(v));\r\n\r\n    let rightUnitaryT = transpose(transposeMultiplyEigenMatrix).reverse();\r\n    let rightUnitary = transpose(rightUnitaryT);\r\n    let leftUnitaryT = transpose(multiplyTransposeEigenMatrix).reverse();\r\n    let leftUnitary = transpose(leftUnitaryT);\r\n\r\n    let diagonal = [];\r\n    if (rowLength <= colLength) {\r\n        for (let i = 0; i < rowLength; i++) {\r\n            diagonal.push(Array(colLength).fill(0));\r\n            if (i < colLength) {\r\n                diagonal[i][i] = multiplyTransposeSingularValues[i];\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < rowLength; i++) {\r\n            diagonal.push(Array(colLength).fill(0));\r\n            if (i < colLength) {\r\n                diagonal[i][i] = transposeMultiplySingularValues[i];\r\n            }\r\n        }\r\n    }\r\n    console.log(\"Ori\", diagonal);\r\n    let diagonalInverse = cloneArray(diagonal);\r\n    for (let i = 0; i < rowLength; i++) {\r\n        if (i < colLength && diagonalInverse[i][i] !== 0) {\r\n            diagonalInverse[i][i] = 1 / diagonalInverse[i][i];\r\n        }\r\n    }\r\n    diagonalInverse = transpose(diagonalInverse);\r\n    const pseudoInverse = multiply(rightUnitary, multiply(diagonalInverse, leftUnitaryT));\r\n    const productInverseRight = multiply(originalMatrix, pseudoInverse); // Right inverse\r\n    const productInverseLeft = multiply(pseudoInverse, originalMatrix); // Right inverse\r\n\r\n    let latexContent = String.raw`\r\n    \\displaystyle\r\n    \\begin{array}{l}\r\n    \\begin{array}{lcl}\r\n    \\\\ AA^{T} = ${matrixToLatex(multiplyTranspose)}\r\n    \\\\\r\n    \\\\ \\text{The eigenvectors of } AA^{T}:\r\n    \\\\\r\n    \\\\ \\bf{U} = \\left[\\begin{matrix}`;\r\n\r\n    for (let i = 0; i < multiplyTransposeEigenMatrix.length; i++) {\r\n        latexContent += String.raw` v_{${i + 1}} ${i === multiplyTransposeEigenMatrix.length - 1 ? '' : '&'} `;\r\n    }\r\n\r\n    latexContent += String.raw`\r\n    \\end{matrix}\\right] = ${matrixToLatex(leftUnitary)}\r\n    \\\\ \r\n    \\\\ \\hline\r\n    \\\\\r\n    \\\\ A^{T}A = ${matrixToLatex(transposeMultiply)}\r\n    \\\\\r\n    \\\\\r\n    \\\\ \\text{The eigenvectors of } A^{T}A:\r\n    \\\\\r\n    \\\\ \\bf{V^{T}} = \\left[\\begin{matrix}`;\r\n\r\n    for (let i = 0; i < transposeMultiplyEigenMatrix.length; i++) {\r\n        latexContent += String.raw` v_{${i + 1}}\\cr `;\r\n    }\r\n\r\n    latexContent += String.raw`\r\n    \\end{matrix}\\right] = ${matrixToLatex(rightUnitaryT)}\r\n    \\\\ \r\n    \\begin{array}{lcl}\r\n    \\\\ \\text{The eigenvalues of } A^{T}A &=& ${transposeMultiplyEigenValues.filter((v) => !isNaN(v)).map((v) => formatMatrixLatex(v))}\r\n    \\\\\r\n    \\\\ \\text{The singular values,} \\ \\sigma &=& \\sqrt{\\text{Eigenvalues}}\r\n    \\\\          &=& ${transposeMultiplySingularValues.filter((v) => !isNaN(v)).map((v) => formatMatrixLatex(v))}\r\n    \\end{array}\r\n    \\\\\r\n    \\\\ \\bf{D} = \\left[\\begin{matrix}`;\r\n    for (let i = 0; i < rowLength; i++) {\r\n        for (let j = 0; j < colLength; j++) {\r\n            if (j === i) {\r\n                latexContent += String.raw`\\colorbox{aqua}{\\bf{${formatMatrixLatex(diagonal[i][j])}}}`;\r\n            }\r\n            else {\r\n                latexContent += String.raw`${formatMatrixLatex(diagonal[i][j])}`;\r\n            }\r\n            if (j !== colLength - 1) {\r\n                latexContent += String.raw`&`;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\cr`;\r\n    }\r\n\r\n    latexContent += String.raw`\r\n    \\end{matrix}\\right]\r\n    \\\\\r\n    \\\\ \\hline\r\n    \\\\ \\begin{array}{lcl}\r\n    \\\\ A &=& ${matrixToLatex(originalMatrix)}\r\n    \\\\\r\n    \\\\ U^{T} &=& ${matrixToLatex(leftUnitaryT)}\r\n    \\\\\r\n    \\\\ D^{+} &=& \\text{Reciprocal of the singular values}\r\n    \\\\\r\n    \\\\       &=& ${matrixToLatex(diagonalInverse)}\r\n    \\\\\r\n    \\\\ V &=& ${matrixToLatex(rightUnitary)}\r\n    \\\\\r\n    \\\\ A^{-1} &=& V D^{+} U^{T}\r\n    \\\\\r\n    \\\\   &=& ${matrixToLatex(rightUnitary)} ${matrixToLatex(diagonalInverse)} ${matrixToLatex(leftUnitaryT)}\r\n    \\\\\r\n    \\\\   &=& ${matrixToLatex(pseudoInverse)}\r\n    \\\\ \\end{array}\r\n    \\\\\r\n    \\\\ \\hline\r\n    \\\\ \\text{To verify the pseudoinverse,}\r\n    \\\\ \\begin{array}{lcl}\r\n    \\\\ AA^{-1} &=& ${matrixToLatex(originalMatrix)} ${matrixToLatex(pseudoInverse)}\r\n    \\\\\r\n    \\\\         &=& ${matrixToLatex(productInverseRight)}\r\n    \\\\\r\n    \\\\ A^{-1}A &=& ${matrixToLatex(pseudoInverse)} ${matrixToLatex(originalMatrix)}\r\n    \\\\\r\n    \\\\         &=& ${matrixToLatex(productInverseLeft)}\r\n    \\\\ \\end{array}\r\n    \\\\\r\n    \\\\ \\hline\r\n    \\\\ \\text{In some cases, } AA^{-1} \\ne I \\text{  or  } A^{-1}A \\ne I \\text{  or even both!}\r\n    \\\\ \\text{The error could be very small due to rounding error. }\r\n    \\\\ \\text{Otherwise, if the error is really huge or if the signs are reversed, this is because the my naive SVD algorithm sometimes}\r\n    \\\\ \\text{fails to properly realign the eigenvector matrices.}\r\n    \\\\ \\text{I'm too lazy to rectify this, sorry!}\r\n    \\end{array}\\end{array}\r\n    `;\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            Note: Errors may occur depending on the matrix used\r\n                            <br />\r\n                            because I've not perfected the algorithm yet.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item className=\"matrix-col-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"subtitle1\">\r\n                                                    Columns:\r\n                                                </Typography>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={columnCallback(false)}>\r\n                                                    <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                                </IconButton>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={columnCallback(true)}>\r\n                                                    <AddCircleOutlineOutlinedIcon />\r\n                                                </IconButton>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"matrix-row-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"subtitle1\">\r\n                                                    Rows:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                                </Typography>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={rowCallback(false)} >\r\n                                                    <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                                </IconButton>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={rowCallback(true)} >\r\n                                                    <AddCircleOutlineOutlinedIcon />\r\n                                                </IconButton>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Matrix, A:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={0} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={gridState.columns}\r\n                                                            rowGetter={i => gridState.rows[i]}\r\n                                                            rowsCount={gridState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Container className={styleClasses.container}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <TeX math={latexContent} block />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                </Grid>\r\n            </Container>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default LinearPenrose;","F:\\numerical-methods-js\\src\\components\\methods\\eigen\\InversePower.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\linear\\Inverse.js",["336"],"import { formatMatrixLatex } from \"../../utils\";\r\nimport { initialMatrix4 as initialMatrix, generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, matrixToLatex } from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport { identity, column as getColumn, lup, usolve, lsolve, multiply, transpose } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".matrix-size-input\",\r\n        title: \"Size\",\r\n        content:\r\n            \"Increase/Reduce the matrix's size\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n            \"Specify the matrix here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearInverse({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const sizeCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                rows.push(createNewRow(gridState.columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n            }\r\n            setGridState({ columns, rows });\r\n        };\r\n    }\r\n\r\n    // Solve\r\n    let solve = true;\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const matrixSize = gridState.rows.length;\r\n    let iterations = matrixSize;\r\n    const lupResult = lup(originalMatrix);\r\n    let lowerMatrix = lupResult.L;\r\n    let upperMatrix = lupResult.U;\r\n    let permutation = lupResult.p;\r\n    let identityMatrix = identity(matrixSize);\r\n    let inverseMatrix = [];\r\n    let results = [];\r\n    let inverseError = false;\r\n    for (let iter = 0; iter < iterations; iter++) {\r\n        let identityColumn = getColumn(identityMatrix, iter).toArray();\r\n        let d, dError = false, x, xError = false;\r\n        try {\r\n            d = lsolve(lowerMatrix, identityColumn).map((v) => v[0]);\r\n        }\r\n        catch {\r\n            dError = true;\r\n        }\r\n        try {\r\n            x = usolve(upperMatrix, d).map((v) => v[0]);\r\n        }\r\n        catch {\r\n            xError = true;\r\n        }\r\n        inverseMatrix.push(x);\r\n        results.push({\r\n            identityColumn,\r\n            d,\r\n            dError,\r\n            x,\r\n            xError,\r\n        });\r\n        if (dError || xError) {\r\n            inverseError = true;\r\n            iterations = iter + 1;\r\n            break;\r\n        }\r\n    }\r\n    if (!inverseError) {\r\n        inverseMatrix = transpose(inverseMatrix);\r\n        inverseMatrix = permutation.map(i => inverseMatrix[i]);\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { originalMatrix, matrixSize, lowerMatrix, upperMatrix, iterations, results, inverseMatrix };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item className=\"matrix-size-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"h6\">\r\n                                                    Size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                                </Typography>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(false)} >\r\n                                                    <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                                </IconButton>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(true)} >\r\n                                                    <AddCircleOutlineOutlinedIcon />\r\n                                                </IconButton>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Matrix, A:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={0} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={gridState.columns}\r\n                                                            rowGetter={i => gridState.rows[i]}\r\n                                                            rowsCount={gridState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ smallScreen, params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let latexContent;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let results = params.results;\r\n        let currentResult = results[currentIteration - 1];\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}`;\r\n        if (currentIteration === 1) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\text{After LU decomposition,}\r\n            \\\\ \\begin{array}{lcl}\r\n            \\\\ A &=& L U\r\n            \\\\\r\n            \\\\   &=& ${matrixToLatex(params.lowerMatrix)} ${matrixToLatex(params.lowerMatrix)}\r\n            \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            `\r\n        }\r\n        latexContent += String.raw`\r\n        \\\\ I_{${currentIteration}} = ${matrixToLatex(currentResult.identityColumn, { single: true })}\r\n        \\\\\r\n        \\\\ \\text{Using backsubstitution,}\r\n        \\\\ \\begin{array}{rcl}\r\n         L d &=& I_{${currentIteration}}\r\n        \\\\\r\n        \\\\ ${matrixToLatex(params.lowerMatrix)} d &=& ${matrixToLatex(currentResult.identityColumn, { single: true })}\r\n        \\\\`\r\n        if (!currentResult.dError) {\r\n            latexContent += String.raw`\r\n            \\\\ d &=& ${matrixToLatex(currentResult.d, { single: true })}\r\n            \\\\ \\end{array}\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\ \\text{Using backsubstitution again,}\r\n            \\\\ \\begin{array}{rcl}\r\n            U x &=& d\r\n            \\\\\r\n            \\\\ ${matrixToLatex(params.upperMatrix)} x &=& ${matrixToLatex(currentResult.d, { single: true })}\r\n            \\\\\r\n            `;\r\n            if (!currentResult.xError) {\r\n                latexContent += String.raw`\r\n                \\\\ x &=& ${matrixToLatex(currentResult.x, { single: true })}\r\n                \\\\ \\end{array}\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ A^{-1}_{${currentIteration}} = x = ${matrixToLatex(currentResult.x, { single: true })}\r\n\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\ \\end{array}\r\n                \\\\ \\text{Given that x cannot be solved,}\r\n                \\\\ \\text{an inverse does not exist.}\r\n                \\\\\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            latexContent += String.raw`\r\n            \\\\ \\end{array}\r\n            \\\\ \\text{Given that d cannot be solved,}\r\n            \\\\ \\text{an inverse does not exist.}\r\n            \\\\\r\n            `;\r\n        }\r\n\r\n        if (currentIteration === params.iterations && !currentResult.dError && !currentResult.xError) {\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\\\\r\n            \\\\ Inverse, A^{-1} = ${matrixToLatex(params.inverseMatrix)}\r\n            \\\\\r\n            \\\\ \\text{To verify the answer,}\r\n            \\\\ \\begin{array}{lcl}\r\n            \\\\ A A^{-1} &=& ${matrixToLatex(params.originalMatrix)} ${matrixToLatex(params.inverseMatrix)}\r\n            \\\\\r\n            \\\\                           &=& ${matrixToLatex(multiply(params.originalMatrix, params.inverseMatrix))}\r\n            \\\\\r\n            \\\\                           &=&  \\text{Identity Matrix}\r\n            \\\\ \\end{array}\r\n            \\\\\r\n            \\\\\r\n            `\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n    }\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                <Grid xs item className=\"iteration-slider\">\r\n                    <Slide direction=\"left\" triggerOnce>\r\n                        <Box id=\"iteration-slider\" width=\"70vw\">\r\n                            <Slider\r\n                                orientation=\"horizontal\"\r\n                                onChangeCommitted={(event, value) => { setCurrentIteration(value) }}\r\n                                defaultValue={1}\r\n                                aria-labelledby=\"discrete-slider-small-steps\"\r\n                                step={1}\r\n                                marks\r\n                                min={1}\r\n                                max={params.iterations <= 0 ? 1 : params.iterations}\r\n                                valueLabelDisplay=\"on\"\r\n                            />\r\n                        </Box>\r\n                    </Slide>\r\n                </Grid>\r\n                <Grid xs item className=\"step-math\">\r\n                    <Slide direction=\"right\" triggerOnce>\r\n                        <Card className={styleClasses.card}>\r\n                            <CardContent className={styleClasses.cardContent}>\r\n                                <Typography variant=\"h6\">\r\n                                    Iteration {currentIteration}:\r\n                                </Typography>\r\n                                <TeX math={latexContent} block />\r\n                            </CardContent>\r\n                        </Card>\r\n                    </Slide>\r\n                </Grid>\r\n            </Grid>\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default LinearInverse;","F:\\numerical-methods-js\\src\\components\\methods\\linear\\SVD.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\linear\\LU.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\linear\\QR.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\linear\\JacobiSeidel.js",["337","338","339"],"import { formatLatex, formatMatrixLatex } from \"../../utils\";\r\nimport {\r\n    initialMatrix3 as initialMatrix, initialInputColumn3 as initialInputColumn, initialOutputColumn3 as initialOutputColumn,\r\n    generateGridCallback, createNewColumn, createNewRow, gridTo2DArray, cloneArray,\r\n    isDiagonallyDominant, numberFactorials, nextPermutation, generatePermutationMapping, matrixToLatex\r\n} from \"../../matrix_utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\n\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Link from '@material-ui/core/Link';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport AddCircleOutlineOutlinedIcon from '@material-ui/icons/AddCircleOutlineOutlined';\r\nimport RemoveCircleOutlineOutlinedIcon from '@material-ui/icons/RemoveCircleOutlineOutlined';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport ReactDataGrid from 'react-data-grid';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".solver-type-input\",\r\n        title: \"Solver Type\",\r\n        content:\r\n            \"Choose either Jacobi or Gauss-Seidel.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".matrix-size-input\",\r\n        title: \"Size\",\r\n        content:\r\n            \"Increase/Reduce the matrix's size\",\r\n    },\r\n    {\r\n        target: \".matrix-input\",\r\n        title: \"Matrix\",\r\n        content:\r\n            \"Specify the matrix here.\",\r\n    },\r\n    {\r\n        target: \".input-col-input\",\r\n        title: \"Input\",\r\n        content:\r\n            \"Specify the initial input vector.\",\r\n    },\r\n    {\r\n        target: \".output-col-input\",\r\n        title: \"Output\",\r\n        content:\r\n            \"Specify the output vector.\",\r\n    },\r\n    {\r\n        target: \".errorThreshold-input\",\r\n        title: \"Error Threshold\",\r\n        content:\r\n            \"Specify the minimum error threshold\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(0.5),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    overflow: {\r\n        overflow: 'auto',\r\n    },\r\n    matrixCard: {\r\n        width: \"60vw\",\r\n    },\r\n    divider: {\r\n        width: '500 px',\r\n        height: '100px',\r\n        marginTop: '20px',\r\n        marginBottom: '20px',\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\nfunction LinearJacobiSeidel({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    // Grid\r\n    const columnWidth = smallScreen ? 45 : 60;\r\n    const rowHeight = smallScreen ? 35 : 35;\r\n    const widthPadding = smallScreen ? 10 : 100;\r\n    const heightPadding = smallScreen ? 5 : 20;\r\n    const [gridState, setGridState] = useState(initialMatrix);\r\n    const [inputColumnState, setInputColumnState] = useState(initialInputColumn);\r\n    const [outputColumnState, setOutputColumnState] = useState(initialOutputColumn);\r\n    const sizeCallback = (add) => {\r\n        return () => {\r\n            const columns = gridState.columns.slice();\r\n            const rows = gridState.rows.slice();\r\n            const inputColumns = inputColumnState.columns.slice();\r\n            const inputRows = inputColumnState.rows.slice();\r\n            const outputColumns = outputColumnState.columns.slice();\r\n            const outputRows = outputColumnState.rows.slice();\r\n            if (add) {\r\n                columns.push(createNewColumn(columns.length));\r\n                rows.push(createNewRow(gridState.columns.length));\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    rows[i][`col_${columns.length}`] = 0;\r\n                }\r\n                inputColumns.push(createNewColumn(inputColumns.length));\r\n                inputRows[0][`col_${inputColumns.length}`] = 0;\r\n                outputColumns.push(createNewColumn(outputColumns.length));\r\n                outputRows[0][`col_${outputColumns.length}`] = 0;\r\n            }\r\n            else {\r\n                if (columns.length === 2) {\r\n                    return;\r\n                }\r\n                rows.pop();\r\n                for (let i = 0; i < outputRows.length; i++) {\r\n                    delete outputRows[i][`col_${outputColumns.length}`];\r\n                }\r\n                for (let i = 0; i < rows.length; i++) {\r\n                    delete rows[i][`col_${columns.length}`];\r\n                }\r\n                columns.pop();\r\n                for (let i = 0; i < inputRows.length; i++) {\r\n                    delete inputRows[i][`col_${inputColumns.length}`];\r\n                }\r\n                inputColumns.pop();\r\n                outputColumns.pop();\r\n            }\r\n            setGridState({ columns, rows });\r\n            setInputColumnState({ columns: inputColumns, rows: inputRows });\r\n            setOutputColumnState({ columns: outputColumns, rows: outputRows });\r\n        };\r\n    }\r\n\r\n    // Solver Type\r\n    const [solverType, setSolverType] = useState(\"jacobi\");\r\n\r\n    // Error threshold\r\n    const [errorThreshold, setErrorThreshold] = useState(0.0002);\r\n    let thresholdError = false;\r\n    let thresholdErrorText = \"\";\r\n    if (isNaN(errorThreshold)) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold must be a number!\";\r\n    }\r\n    else if (errorThreshold < 0) {\r\n        thresholdError = true;\r\n        thresholdErrorText = \"Threshold cannot be negative!\";\r\n    }\r\n\r\n    let hasError = thresholdError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let exceedIterError = false;\r\n    let exceedIterErrorText = \"\";\r\n    const originalMatrix = gridTo2DArray(gridState.rows);\r\n    const originalOutput = gridTo2DArray(outputColumnState.rows)[0];\r\n    const originalInput = gridTo2DArray(inputColumnState.rows)[0];\r\n    let modifiedInput = cloneArray(originalInput);\r\n    const matrixSize = gridState.rows.length;\r\n    let results = [];\r\n    let iterations = 0;\r\n    let permutated = false;\r\n    let triedPermutating = false; // Failed to obtain a dominant matrix even after permutating.\r\n    if (!hasError) {\r\n        solve = true;\r\n        let dominant = false; // Strictly diagonally dominant\r\n        let modifiedMatrix = cloneArray(originalMatrix);\r\n        let modifiedOutput = cloneArray(originalOutput);\r\n        console.log(\"Original: \", modifiedMatrix);\r\n        if (!isDiagonallyDominant(modifiedMatrix)) {\r\n            console.log(\"Initially not dominant!\");\r\n            let numPermutations = numberFactorials[matrixSize];\r\n            let rowIndexes = [...Array(matrixSize).keys()];\r\n            for (let i = 0; i < numPermutations - 1; i++) {\r\n                nextPermutation(rowIndexes);\r\n                const permutatedMatrix = rowIndexes.map(ind => modifiedMatrix[ind]);\r\n                if (isDiagonallyDominant(permutatedMatrix)) {\r\n                    dominant = true;\r\n                    modifiedMatrix = permutatedMatrix;\r\n                    modifiedOutput = rowIndexes.map(ind => modifiedOutput[ind]);\r\n                    console.log(\"Found a dominant!\", modifiedMatrix, modifiedOutput, rowIndexes);\r\n                    break;\r\n                }\r\n            }\r\n            if (dominant) {\r\n                results.push({\r\n                    newMatrix: cloneArray(modifiedMatrix),\r\n                    newOutput: cloneArray(modifiedOutput),\r\n                    newInput: cloneArray(modifiedInput),\r\n                    permutated: true,\r\n                    rowIndexes: rowIndexes,\r\n                });\r\n                permutated = true;\r\n                iterations += 1;\r\n            }\r\n            else {\r\n                console.log(\"Tried permutating but failed!\");\r\n                triedPermutating = true;\r\n            }\r\n        }\r\n        else {\r\n            console.log(\"Initially dominant!\");\r\n            dominant = true;\r\n        }\r\n\r\n        if (dominant) {\r\n            console.log(\"Solve Dominant!\");\r\n            let i = 0;\r\n            while (true) {\r\n                let oldInput = (i === 0) ? originalInput : results[i - 1 + iterations].newInput;\r\n                let newInput = [];\r\n                for (let j = 0; j < matrixSize; j++) {\r\n                    let sum = modifiedOutput[j];\r\n                    if (solverType === \"jacobi\") {\r\n                        for (let k = 0; k < matrixSize; k++) {\r\n                            if (k !== j) {\r\n                                sum -= modifiedMatrix[j][k] * oldInput[k];\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (let k = 0; k < matrixSize; k++) {\r\n                            if (k < j) {\r\n                                sum -= modifiedMatrix[j][k] * newInput[k];\r\n                            }\r\n                            else if (k > j) {\r\n                                sum -= modifiedMatrix[j][k] * oldInput[k];\r\n                            }\r\n                        }\r\n                    }\r\n                    sum /= modifiedMatrix[j][j];\r\n                    newInput.push(sum);\r\n                }\r\n                let errorInput = newInput.map((v, index) => Math.abs(v - oldInput[index]));\r\n                let converged = true;\r\n                for (let j = 0; j < matrixSize; j++) {\r\n                    if (errorInput[j] >= errorThreshold) {\r\n                        converged = false;\r\n                        break;\r\n                    }\r\n                }\r\n                results.push({\r\n                    oldInput,\r\n                    newInput,\r\n                    errorInput,\r\n                    converged,\r\n                });\r\n\r\n                i++;\r\n                if (converged) {\r\n                    console.log(\"Converged\");\r\n                    break;\r\n                }\r\n                if (i > 1000) {\r\n                    console.log(\"Exceeded 1000 iterations!\");\r\n                    exceedIterError = true;\r\n                    exceedIterErrorText = \"Exceeded 1000 iterations! Try increasing the error threshold.\";\r\n                    break;\r\n                }\r\n            }\r\n            iterations += i;\r\n        }\r\n    }\r\n    console.log(results);\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true)\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { solverType, originalMatrix, originalInput, originalOutput, matrixSize, errorThreshold, iterations, exceedIterError, exceedIterErrorText, results, permutated, triedPermutating };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            This method is applied to matrices in the form of\r\n                            <TeX math={String.raw`\\ Ax=B`} /> .\r\n                            <br />\r\n                            Warning: The process of finding a diagonally-dominant form may be slow for matrices 7x7 and beyond\r\n                            <br />\r\n                            because it needs to search through all the possible permutations.\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Grid container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                            <Grid xs item className=\"solver-type-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"h6\">\r\n                                                    Solver Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                                </Typography>\r\n                                                <RadioGroup aria-label=\"solverType\" name=\"solverType\" value={solverType} onChange={(event) => setSolverType(event.target.value)}>\r\n                                                    <FormControlLabel value=\"jacobi\" control={<Radio />} label=\"Jacobi\" />\r\n                                                    <FormControlLabel value=\"seidel\" control={<Radio />} label=\"Gauss-Seidel\" />\r\n                                                </RadioGroup>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"matrix-size-input\" container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                <Typography variant=\"h6\">\r\n                                                    Size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                                </Typography>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(false)} >\r\n                                                    <RemoveCircleOutlineOutlinedIcon color=\"error\" />\r\n                                                </IconButton>\r\n                                                <IconButton variant=\"contained\" color=\"primary\" onClick={sizeCallback(true)} >\r\n                                                    <AddCircleOutlineOutlinedIcon />\r\n                                                </IconButton>\r\n                                            </Grid>\r\n\r\n                                            <Grid xs item className=\"matrix-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Matrix, A:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={0} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={gridState.columns}\r\n                                                            rowGetter={i => gridState.rows[i]}\r\n                                                            rowsCount={gridState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(gridState, setGridState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * gridState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * gridState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n\r\n                                            <Grid xs item className=\"input-col-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Initial Input, <TeX math={String.raw`X^{(0)}`} />:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={1} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={inputColumnState.columns}\r\n                                                            rowGetter={i => inputColumnState.rows[i]}\r\n                                                            rowsCount={inputColumnState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(inputColumnState, setInputColumnState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * inputColumnState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * inputColumnState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"output-col-input\" container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                                                <Grid xs item>\r\n                                                    <Typography variant=\"h6\">\r\n                                                        Output, B:\r\n                                                    </Typography>\r\n                                                </Grid>\r\n                                                <Grid xs item container spacing={0} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                                                    <Grid key={2} item className={styleClasses.overflow}>\r\n                                                        <ReactDataGrid\r\n                                                            columns={outputColumnState.columns}\r\n                                                            rowGetter={i => outputColumnState.rows[i]}\r\n                                                            rowsCount={outputColumnState.rows.length}\r\n                                                            onGridRowsUpdated={generateGridCallback(outputColumnState, setOutputColumnState)}\r\n                                                            enableCellSelect={true}\r\n                                                            headerRowHeight={1}\r\n                                                            minColumnWidth={columnWidth}\r\n                                                            minWidth={columnWidth * outputColumnState.columns.length + widthPadding}\r\n                                                            rowHeight={rowHeight}\r\n                                                            minHeight={rowHeight * outputColumnState.rows.length + heightPadding}\r\n                                                        />\r\n                                                    </Grid>\r\n                                                </Grid>\r\n                                            </Grid>\r\n                                            <Grid xs item className=\"errorThreshold-input\">\r\n                                                <Card className={styleClasses.card}>\r\n                                                    <CardContent className={styleClasses.cardContent}>\r\n                                                        <Typography variant=\"h6\">\r\n                                                            Error threshold:\r\n                                                        </Typography>\r\n                                                        <TextField\r\n                                                            disabled={false}\r\n                                                            type=\"number\"\r\n                                                            onChange={(event) => setErrorThreshold(parseFloat(event.target.value))}\r\n                                                            error={thresholdError}\r\n                                                            label={thresholdError ? \"Error\" : \"\"}\r\n                                                            defaultValue={errorThreshold.toString()}\r\n                                                            helperText={thresholdErrorText}\r\n                                                            variant=\"outlined\"\r\n                                                        />\r\n                                                    </CardContent>\r\n                                                </Card>\r\n                                            </Grid>\r\n                                        </Grid>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps smallScreen={smallScreen} params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ smallScreen, params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n    let hasError = params.exceedIterError;\r\n    let errorText = params.exceedIterErrorText;\r\n    let latexContent;\r\n\r\n    if (currentIteration <= 0) {\r\n        setCurrentIteration(1);\r\n    }\r\n    else if (params.iterations > 0 && currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else if (params.triedPermutating) {\r\n        // Failed even after permutating the matrix\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\text{Cannot find a diagonally dominant matrix.}\r\n        \\\\ \\overbrace{${matrixToLatex(params.originalMatrix, { leftBracketOnly: true })}}^{A}\r\n           \\overbrace{${matrixToLatex(params.originalInput, { single: true })}}^{X_{0}}\r\n        &=&\\overbrace{${matrixToLatex(params.originalOutput, { single: true })}}^{B}\r\n        \\end{array}\r\n        `;\r\n    }\r\n    else if (params.iterations > 0) {\r\n        let results = params.results;\r\n        let currentResult = results[currentIteration - 1];\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\\\ \\begin{array}{lcl}\r\n        `;\r\n        if (currentResult.permutated) {\r\n            const permutationMapping = generatePermutationMapping(currentResult.rowIndexes);\r\n            const boldRows = Object.keys(permutationMapping).map((v) => parseInt(v) + 1);\r\n            boldRows.push(...Object.values(permutationMapping).map((v) => v + 1));\r\n            const previousLatex = String.raw`\r\n            \\overbrace{${matrixToLatex(params.originalMatrix, { leftBracketOnly: true, boldRows: boldRows })}}^{A}\r\n            \\overbrace{${matrixToLatex(params.originalOutput, { single: true, rightBracketOnly: true, boldRows: boldRows })}}^{B}`;\r\n            let operationLatex = String.raw`\\begin{array}{l}`;\r\n            for (const [key, value] of Object.entries(permutationMapping)) {\r\n                operationLatex += String.raw`R_{${parseInt(key) + 1}} \\leftrightarrow R_{${value + 1}}\\\\`;\r\n            }\r\n            operationLatex += String.raw`\\end{array}`;\r\n            const newLatex = String.raw`\r\n            \\overbrace{${matrixToLatex(currentResult.newMatrix, { leftBracketOnly: true, boldRows: boldRows })}}^{A}\r\n            \\overbrace{${matrixToLatex(currentResult.newOutput, { single: true, rightBracketOnly: true, boldRows: boldRows })}}^{B}`;\r\n            latexContent += String.raw`\r\n            \\\\ \\text{The matrix's rows are } \\textbf{permutated} ${smallScreen ? \"\\\\\\\\\" : \"\"} \\text{ to make it } \\textbf{strictly diagonally dominant.}\r\n            \\\\`\r\n            if (smallScreen) {\r\n                latexContent += String.raw`\r\n                \\\\ ${previousLatex}\r\n                \\\\ \\begin{array}{lcl}\r\n                    & \\downarrow &\r\n                    \\\\ & ${operationLatex} &\r\n                    \\\\ & \\downarrow &\r\n                    \\end{array}\r\n                \\\\ ${newLatex}\r\n                `;\r\n            }\r\n            else {\r\n                latexContent += String.raw`\r\n                \\\\ \\begin{array}{lcl}\r\n                \\\\ ${previousLatex}\r\n                    & \\overrightarrow{${operationLatex}}\r\n                    & ${newLatex}\r\n                    \\end{array}\r\n                `;\r\n            }\r\n        }\r\n        else {\r\n            let index = params.permutated ? currentIteration - 1 : currentIteration;\r\n            let matrix = params.permutated ? results[0].newMatrix : params.originalMatrix;\r\n            let output = params.permutated ? results[0].newOutput : params.originalOutput;\r\n            let solverExpressionLatex = params.solverType === \"jacobi\" ?\r\n                String.raw`\r\n            X^{(${index})}_i &=& \\frac{1}{A_{ii}}\r\n                \\left[ B_i - \\sum_{\\substack{j = 1, \\\\ j \\ne i}}^n \\left( A_{ij} \\cdot X^{(${index - 1})}_j \\right)\r\n                \\right]`\r\n                :\r\n                String.raw`\r\n            X^{(${index})}_i &=& \\frac{1}{A_{ii}}\r\n                \\left[ B_i - \\sum_{\\substack{j = 1}}^{i-1} \\left( A_{ij} \\cdot X^{(${index})}_j \\right)\r\n                           - \\sum_{\\substack{j = i+1}}^{n} \\left( A_{ij} \\cdot X^{(${index - 1})}_j \\right)\r\n\r\n                \\right]`;\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\overbrace{${matrixToLatex(matrix, { leftBracketOnly: true })}}^{A}\r\n            \\overbrace{${matrixToLatex(currentResult.oldInput, { single: true })}}^{X^{(${index - 1})}}\r\n            = \\overbrace{${matrixToLatex(output, { single: true })}}^{B}\r\n            \\\\\r\n            \\begin{array}{lcl}\r\n            \\\\ ${solverExpressionLatex}\r\n            \\\\\r\n            \\\\ &=& \\left[\\begin{matrix}\r\n            `;\r\n            for (let i = 0; i < params.matrixSize; i++) {\r\n                latexContent += String.raw`\\frac{1}{${formatMatrixLatex(matrix[i][i])}} \\left[ ${formatMatrixLatex(output[i])}`;\r\n                if (params.solverType === \"jacobi\") {\r\n                    for (let j = 0; j < params.matrixSize; j++) {\r\n                        if (j !== i) {\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.oldInput[j])}) `;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (let j = 0; j < params.matrixSize; j++) {\r\n                        if (j < i) {\r\n                            //sum -= modifiedMatrix[i][j] * newInput[j];\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.newInput[j])}) `;\r\n                        }\r\n                        else if (j > i) {\r\n                            //sum -= modifiedMatrix[i][j] * oldInput[j];\r\n                            latexContent += String.raw`- (${formatMatrixLatex(matrix[i][j])}) (${formatMatrixLatex(currentResult.oldInput[j])}) `;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                latexContent += String.raw`\\right] \\cr`;\r\n            }\r\n\r\n            latexContent += String.raw`\r\n            \\end{matrix}\\right]\r\n            \\\\\r\n            \\\\ X^{(${index})} &=& ${matrixToLatex(currentResult.newInput, { single: true })}\r\n            \\end{array}\r\n            `;\r\n            if (results[0].permutated) {\r\n                // Reorder the equations\r\n                let restoredOutput = cloneArray(currentResult.newInput);\r\n                restoredOutput = results[0].rowIndexes.map(ind => restoredOutput[ind]);\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text {Given that the matrix A has been permutated in iteration 1, }\r\n                \\\\ \\text {we must restore it to the original order:}\r\n                \\\\\r\n                \\\\ X^{(${index})}_{restored} = ${matrixToLatex(restoredOutput, { single: true })}\r\n                `;\r\n            }\r\n            latexContent += String.raw`\r\n            \\\\\r\n            \\\\ \\hline\r\n            \\begin{array}{lcl}\r\n            \\\\ Error &=& |X^{(${index})} - X^{(${index - 1})}|\r\n            \\\\       &=& |${formatLatex(currentResult.errorInput)}|\r\n            \\end{array}\r\n            `;\r\n            if (currentResult.converged) {\r\n                latexContent += String.raw`\r\n                \\\\\r\n                \\\\ \\hline\r\n                \\\\ \\text{Converged because:}\r\n                \\\\\r\n                \\\\ Error < Error Threshold\r\n                \\\\ ${formatLatex(currentResult.errorInput)} < ${formatLatex(params.errorThreshold)}\r\n                `;\r\n            }\r\n        }\r\n        latexContent += String.raw`\\end{array}\\end{array}`;\r\n\r\n    }\r\n    else {\r\n        latexContent = String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lcl}\r\n        \\\\ \\text{Cannot do anything.}\r\n        \\\\ \\overbrace{${matrixToLatex(params.originalMatrix, { leftBracketOnly: true })}}^{A}\r\n           \\overbrace{${matrixToLatex(params.originalInput, { single: true })}}^{X_{0}}\r\n        &=&\\overbrace{${matrixToLatex(params.originalOutput, { single: true })}}^{B}\r\n        \\end{array}\r\n        `;\r\n    }\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid container direction=\"column\" alignItems=\"center\" justify=\"flex-start\">\r\n                    <Grid xs item>\r\n                        <Zoom triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Converged after {params.iterations} iterations\r\n                                    </Typography>\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Zoom>\r\n                    </Grid>\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" width=\"70vw\">\r\n                                <Slider\r\n                                    orientation=\"horizontal\"\r\n                                    onChangeCommitted={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={currentIteration}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations <= 0 ? 1 : params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item className=\"step-math\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Card className={styleClasses.card}>\r\n                                <CardContent className={styleClasses.cardContent}>\r\n                                    <Typography variant=\"h6\">\r\n                                        Iteration {currentIteration}:\r\n                                    </Typography>\r\n                                    <TeX math={latexContent} />\r\n                                </CardContent>\r\n                            </Card>\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n            </Collapse>\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default LinearJacobiSeidel;","F:\\numerical-methods-js\\src\\components\\methods\\linear\\Gauss.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\FixedPoint.js",["340"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the fixed point method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearFixedPoint({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`\\frac{3-x^3}{6}`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(1.5);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX : results[i - 1].newX;\r\n            let funcResult;\r\n            try {\r\n                funcResult = functionValue.evaluate({ x: previousX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n\r\n            let newX = funcResult;\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                funcResult,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, iterations, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Typography variant=\"body1\">\r\n                            It is assumed that the user has already rearranged the original function into the form\r\n                            <TeX math={String.raw`\\ x=f(x)`} />\r\n                            .\r\n                        </Typography>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, f(x):\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialX-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial value, <TeX math={String.raw`x_0`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setInitialX(parseFloat(event.target.value))}\r\n                                            error={initialXError}\r\n                                            label={initialXError ? \"Error\" : \"\"}\r\n                                            defaultValue={initialX.toString()}\r\n                                            helperText={initialXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lll}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ ${newXLatex} &=& f(${previousXLatex})\r\n        \\\\              &=& ${formatLatex(currentResult.newX)}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel: true, latex:\r\n                    `(${currentResult.previousX}, ${currentResult.funcResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearFixedPoint;","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Secant.js",["341"],"import { isValidMath, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".perturbation-input\",\r\n        title: \"Perturbation\",\r\n        content:\r\n            \"Specify the perturbation fraction. Higher values produce a better approximation.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply the modified secant method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearSecant({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Perturbation\r\n    const [perturbation, setPerturbation] = useState(0.01);\r\n    let perturbationError = false;\r\n    let perturbationErrorText = \"\";\r\n    if (perturbation <= 0) {\r\n        perturbationError = true;\r\n        perturbationErrorText = \"Perturbation must be a positive integer!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(3.5);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || perturbationError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX : results[i - 1].newX;\r\n            let perturbedX = previousX * (1 + perturbation);\r\n            let funcResult, funcResult2;\r\n            try {\r\n                funcResult = functionValue.evaluate({ x: previousX });\r\n                funcResult2 = functionValue.evaluate({ x: perturbedX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n\r\n            let newX = previousX - perturbation * previousX * funcResult / (funcResult2 - funcResult);\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                perturbedX,\r\n                funcResult,\r\n                funcResult2,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, perturbation, iterations, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function, f(x):\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"perturbation-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Perturbation fraction, <TeX math={String.raw`\\delta`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setPerturbation(parseFloat(event.target.value))}\r\n                                            error={perturbationError}\r\n                                            label={perturbationError ? \"Error\" : \"\"}\r\n                                            defaultValue={perturbation.toString()}\r\n                                            helperText={perturbationErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialX-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial value, <TeX math={String.raw`x_0`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setInitialX(parseFloat(event.target.value))}\r\n                                            error={initialXError}\r\n                                            label={initialXError ? \"Error\" : \"\"}\r\n                                            defaultValue={initialX.toString()}\r\n                                            helperText={initialXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            {\"\"}\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let perturbedXLatex = String.raw`${previousXLatex} + \\delta \\cdot ${previousXLatex}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{l}\r\n        \\begin{array}{lcl}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ ${perturbedXLatex} &=& ${formatLatex(currentResult.perturbedX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ f(${perturbedXLatex}) &=& ${formatLatex(currentResult.funcResult2)}\r\n        \\\\ ${newXLatex} &=& ${previousXLatex} - \\frac{\\delta \\cdot ${previousXLatex} \\cdot f(${previousXLatex})}{f(${perturbedXLatex}) - f(${previousXLatex})}\r\n        \\\\              &=& ${formatLatex(currentResult.newX)}\r\n        \\end{array}\r\n        \\\\\r\n        \\begin{array}{lcl}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'derivative', color: Desmos.Colors.GREEN, lineStyle: Desmos.Styles.DOTTED, latex:\r\n                    `(y-${currentResult.funcResult})/(x-${currentResult.previousX})=${(currentResult.funcResult2 - currentResult.funcResult) / (params.perturbation * currentResult.previousX)}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel: true, latex:\r\n                    `(${currentResult.previousX}, ${currentResult.funcResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => setCurrentIteration(value)}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n                        <Slide direction=\"right\" triggerOnce>\r\n                            <Graph params={{ currentIteration, graphCallback, smallScreen, ...params }} />\r\n                        </Slide>\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearSecant;","F:\\numerical-methods-js\\src\\components\\methods\\nonlinear\\Newton.js",["342"],"import { isValidMath, mathjsToLatex, mathjsKeywords, formatLatex } from \"../../utils\";\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Header from \"../../header/Header\";\r\nimport Graph from \"../../Graph\";\r\nimport * as Desmos from 'desmos';\r\n\r\nimport { addStyles, EditableMathField } from 'react-mathquill';\r\nimport { parse, derivative } from 'mathjs';\r\nimport 'katex/dist/katex.min.css';\r\nimport TeX from '@matejmazur/react-katex';\r\n\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Container from '@material-ui/core/Container';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport { Alert } from '@material-ui/lab';\r\nimport Box from '@material-ui/core/Box';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Fab from '@material-ui/core/Fab';\r\nimport HelpIcon from '@material-ui/icons/Help';\r\nimport Joyride, { Step as JoyrideStep, CallBackProps as JoyrideCallBackProps } from \"react-joyride\";\r\nimport Collapse from '@material-ui/core/Collapse';\r\nimport { Fade, Zoom, Slide } from \"react-awesome-reveal\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nconst TOUR_STEPS: JoyrideStep[] = [\r\n    {\r\n        target: \".function-input\",\r\n        title: \"Function\",\r\n        content:\r\n            \"Type a math function which only has the variable x. cos(x), sin(x) and e^x are supported.\",\r\n        disableBeacon: true,\r\n    },\r\n    {\r\n        target: \".derivative-input\",\r\n        title: \"Derivative\",\r\n        content:\r\n            \"The function's derivative will be shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-input\",\r\n        title: \"Iterations\",\r\n        content:\r\n            \"Specify the number of iterations to apply Newton's method.\",\r\n    },\r\n    {\r\n        target: \".initialX-input\",\r\n        title: \"Initial x value\",\r\n        content:\r\n            \"Specify the initial/starting value of x.\",\r\n    },\r\n    {\r\n        target: \".results\",\r\n        title: \"Results\",\r\n        content:\r\n            \"The results are shown here.\",\r\n    },\r\n    {\r\n        target: \".iteration-slider\",\r\n        title: \"Iteration slider\",\r\n        content:\r\n            \"Change the slider to view the result of any iteration.\",\r\n    },\r\n    {\r\n        target: \".step-math\",\r\n        title: \"Steps\",\r\n        content:\r\n            \"The steps for each iteration are shown here.\",\r\n    },\r\n    {\r\n        target: \".graph-button\",\r\n        title: \"View graph\",\r\n        content:\r\n            \"Click this to visualise the results.\",\r\n    },\r\n];\r\n\r\n// Styles\r\nconst useStyles = makeStyles((theme) => ({\r\n    paper: {\r\n        padding: theme.spacing(2),\r\n        textAlign: 'center',\r\n        color: theme.palette.text.primary,\r\n        margin: theme.spacing(1),\r\n    },\r\n    container: {\r\n        \"& > *\": {\r\n            margin: theme.spacing(1)\r\n        }\r\n    },\r\n    card: {\r\n        margin: theme.spacing(0.5),\r\n    },\r\n    cardContent: {\r\n        overflow: 'auto',\r\n        \"& > *\": {\r\n            margin: theme.spacing(0.5)\r\n        }\r\n    },\r\n    fab: {\r\n        position: 'fixed',\r\n        bottom: theme.spacing(4),\r\n        right: theme.spacing(2),\r\n    },\r\n}));\r\n\r\naddStyles(); // inserts the required css to the <head> block for mathquill\r\n\r\nfunction NonlinearNewton({ methodName, markdown }) {\r\n    useEffect(() => {\r\n        // Set webpage title\r\n        document.title = methodName;\r\n    });\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    // Derivative\r\n    // Another sample would be: `3x^2+2x-8`\r\n    const [functionLatex, setFunctionLatex] = useState(String.raw`x-\\cos\\left( x\\right)`);\r\n    const [functionText, setFunctionText] = useState('');\r\n\r\n    let functionValue, derivValue, derivLatex;\r\n    let functionError = false;\r\n    let functionErrorText = \"\";\r\n    try {\r\n        functionValue = parse(functionText);\r\n        derivValue = derivative(functionText, 'x');\r\n        derivLatex = mathjsToLatex(derivValue);\r\n        functionValue.traverse(function (node, path, parent) {\r\n            if (node.type === 'SymbolNode' && !mathjsKeywords.includes(node.name)) {\r\n                if (node.name !== 'x') {\r\n                    throw \"variableName\";\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        functionError = true;\r\n        functionErrorText = e === \"variableName\" ? \"Only x variable is allowed.\" : \"Invalid equation!\";\r\n    }\r\n\r\n    // Iterations\r\n    const [iterations, setIterations] = useState(10);\r\n    let iterError = false;\r\n    let iterErrorText = \"\";\r\n    if (!Number.isInteger(iterations) || iterations <= 0) {\r\n        iterError = true;\r\n        iterErrorText = \"Iterations must be a positive integer!\";\r\n    }\r\n\r\n    // Initial x\r\n    const [initialX, setInitialX] = useState(0.0);\r\n    let initialXError = false;\r\n    let initialXErrorText = \"\";\r\n    if (isNaN(initialX)) {\r\n        initialXError = true;\r\n        initialXErrorText = \"Initial x must be a number!\";\r\n    }\r\n\r\n    let hasError = functionError || iterError || initialXError;\r\n\r\n    // Solve\r\n    let solve = false;\r\n    let results = [];\r\n    if (isValidMath(functionValue) && !hasError) {\r\n        solve = true;\r\n        for (let i = 0; i < iterations; i++) {\r\n            let previousX = (i === 0) ? initialX : results[i - 1].newX;\r\n            let funcResult, derivResult;\r\n            try {\r\n                funcResult = functionValue.evaluate({ x: previousX });\r\n                derivResult = derivValue.evaluate({ x: previousX });\r\n            }\r\n            catch {\r\n                hasError = true;\r\n                functionError = true;\r\n                functionErrorText = \"Only variable x is allowed!\";\r\n                solve = false;\r\n                break;\r\n            }\r\n\r\n            let newX = previousX - funcResult / derivResult;\r\n            let errorX = Math.abs(newX - previousX);\r\n            results.push({\r\n                previousX,\r\n                funcResult,\r\n                derivResult,\r\n                newX,\r\n                errorX,\r\n            });\r\n        }\r\n    }\r\n\r\n    // Joyride Tour\r\n    const [runTour, setRunTour] = useState(false);\r\n    const openHelp = () => {\r\n        setRunTour(true);\r\n    };\r\n    const joyrideCallback = (state: JoyrideCallBackProps) => {\r\n        if (state.action === \"reset\" || state.action === \"close\") {\r\n            setRunTour(false);\r\n        }\r\n    };\r\n\r\n    let params = { functionLatex, iterations, results };\r\n\r\n    return (\r\n        <>\r\n            <Header methodName={methodName} markdown={markdown} />\r\n            <Paper className={styleClasses.paper}>\r\n                <Container className={styleClasses.container}>\r\n                    <Zoom duration={500} triggerOnce cascade>\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"function-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Function:\r\n                                        </Typography>\r\n                                        <EditableMathField\r\n                                            disabled={false}\r\n                                            latex={functionLatex}\r\n                                            onChange={(mathField) => {\r\n                                                setFunctionText(mathField.text());\r\n                                                setFunctionLatex(mathField.latex());\r\n                                            }}\r\n                                            mathquillDidMount={(mathField) => {\r\n                                                setFunctionText(mathField.text())\r\n                                            }}\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"derivative-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Derivative:\r\n                                        </Typography>\r\n                                        <Collapse in={functionError}>\r\n                                            <Alert severity=\"error\">\r\n                                                {functionErrorText}\r\n                                            </Alert>\r\n                                        </Collapse>\r\n                                        <Collapse in={!functionError}>\r\n                                            {!functionError && <Fade triggerOnce><TeX math={derivLatex} block /></Fade>}\r\n                                        </Collapse>\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n\r\n\r\n                        <Grid container spacing={1} direction=\"row\" alignItems=\"center\" justify=\"center\">\r\n                            <Grid xs item className=\"iteration-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iterations:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setIterations(parseInt(event.target.value))}\r\n                                            error={iterError}\r\n                                            label={iterError ? \"Error\" : \"\"}\r\n                                            defaultValue={iterations.toString()}\r\n                                            helperText={iterErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                            <Grid xs item className=\"initialX-input\">\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Initial value, <TeX math={String.raw`x_0`} />:\r\n                                        </Typography>\r\n                                        <TextField\r\n                                            disabled={false}\r\n                                            type=\"number\"\r\n                                            onChange={(event) => setInitialX(parseFloat(event.target.value))}\r\n                                            error={initialXError}\r\n                                            label={initialXError ? \"Error\" : \"\"}\r\n                                            defaultValue={initialX.toString()}\r\n                                            helperText={initialXErrorText}\r\n                                            variant=\"outlined\"\r\n                                        />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Grid>\r\n                        </Grid>\r\n                    </Zoom>\r\n                </Container>\r\n            </Paper>\r\n\r\n            <Divider />\r\n\r\n            <Collapse in={solve}>\r\n                <Fade triggerOnce>\r\n                    <Paper className={styleClasses.paper}>\r\n                        {solve && <Steps params={params} />}\r\n                    </Paper>\r\n                </Fade>\r\n            </Collapse>\r\n            <Tooltip arrow title=\"Help\" placement=\"top\">\r\n                <Fab color=\"secondary\" aria-label=\"help\" className={styleClasses.fab} onClick={openHelp}>\r\n                    <HelpIcon />\r\n                </Fab>\r\n            </Tooltip>\r\n            <Joyride\r\n                scrollToFirstStep\r\n                run={runTour}\r\n                steps={TOUR_STEPS}\r\n                continuous={true}\r\n                showSkipButton={true}\r\n                locale={{\r\n                    last: \"End tour\",\r\n                }}\r\n                callback={joyrideCallback}\r\n            />\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Steps({ params }) {\r\n\r\n    const styleClasses = useStyles();\r\n\r\n    const [currentIteration, setCurrentIteration] = useState(1);\r\n\r\n    let hasError = false;\r\n    let errorText = \"\";\r\n\r\n    let results = params.results;\r\n    let currentResult = results[currentIteration - 1];\r\n\r\n    let latexContent, graphCallback;\r\n\r\n    if (currentIteration > params.iterations) {\r\n        setCurrentIteration(params.iterations);\r\n    }\r\n    else {\r\n        let previousXLatex = String.raw`x_{${currentIteration - 1}}`;\r\n        let newXLatex = String.raw`x_{${currentIteration}}`;\r\n        latexContent =\r\n            String.raw`\r\n        \\displaystyle\r\n        \\begin{array}{lll}\r\n        \\\\ ${previousXLatex} &=& ${formatLatex(currentResult.previousX)}\r\n        \\\\ f(${previousXLatex}) &=& ${formatLatex(currentResult.funcResult)}\r\n        \\\\ f'(${previousXLatex}) &=& ${formatLatex(currentResult.derivResult)}\r\n        \\\\ ${newXLatex} &=& ${previousXLatex} - \\frac{f(${previousXLatex})}{f'(${previousXLatex})}\r\n        \\\\                       &=& ${formatLatex(currentResult.newX)}\r\n        \\\\ Error &=& |${newXLatex} - ${previousXLatex}|\r\n        \\\\       &=& |${formatLatex(currentResult.errorX)}|\r\n        \\end{array}\r\n        `;\r\n\r\n        graphCallback = (calculator, currentResult) => {\r\n            calculator.current.setExpression({ id: 'function', color: Desmos.Colors.BLUE, latex: params.functionLatex });\r\n            calculator.current.setExpression({\r\n                id: 'derivative', color: Desmos.Colors.GREEN, lineStyle: Desmos.Styles.DOTTED, latex:\r\n                    `(y-${currentResult.funcResult})/(x-${currentResult.previousX})=${currentResult.derivResult}`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'initialX', color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.POINT, label: \"initialX\", showLabel: true, latex:\r\n                    `(${currentResult.previousX}, ${currentResult.funcResult})`\r\n            });\r\n            calculator.current.setExpression({\r\n                id: 'root', color: Desmos.Colors.RED, pointStyle: Desmos.Styles.POINT, label: \"Root\", showLabel: true, latex:\r\n                    `(${currentResult.newX}, 0)`\r\n            });\r\n        }\r\n    }\r\n\r\n    const smallScreen = useMediaQuery(useTheme().breakpoints.down('sm'));\r\n\r\n    return (\r\n        <Container className={styleClasses.container}>\r\n\r\n            <Collapse in={hasError}>\r\n                <Alert severity=\"error\">\r\n                    {errorText}\r\n                </Alert>\r\n            </Collapse>\r\n            <Collapse in={!hasError}>\r\n                <Grid className=\"results\" container direction={smallScreen ? \"column\" : \"row\"} alignItems=\"center\" justify=\"space-evenly\">\r\n                    <Grid xs item className=\"iteration-slider\">\r\n                        <Slide direction=\"left\" triggerOnce>\r\n                            <Box id=\"iteration-slider\" height={smallScreen ? null : \"20rem\"} width={smallScreen ? \"70vw\" : null}>\r\n                                <Slider\r\n                                    orientation={smallScreen ? \"horizontal\" : \"vertical\"}\r\n                                    onChange={(event, value) => { setCurrentIteration(value) }}\r\n                                    defaultValue={1}\r\n                                    aria-labelledby=\"discrete-slider-small-steps\"\r\n                                    step={1}\r\n                                    marks\r\n                                    min={1}\r\n                                    max={params.iterations}\r\n                                    valueLabelDisplay=\"on\"\r\n                                />\r\n                            </Box>\r\n                        </Slide>\r\n                    </Grid>\r\n                    <Grid xs item container spacing={1} direction=\"column\" alignItems=\"center\" justify=\"center\">\r\n                        <Grid xs item className=\"step-math\">\r\n                            <Zoom duration={500} triggerOnce>\r\n                                <Card className={styleClasses.card}>\r\n                                    <CardContent className={styleClasses.cardContent}>\r\n                                        <Typography variant=\"h6\">\r\n                                            Iteration {currentIteration}:\r\n                                        </Typography>\r\n                                        <TeX math={latexContent} block />\r\n                                    </CardContent>\r\n                                </Card>\r\n                            </Zoom>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid xs item className=\"graph-button\">\r\n\r\n                    </Grid>\r\n                </Grid>\r\n\r\n            </Collapse>\r\n\r\n        </Container>\r\n    )\r\n}\r\n\r\nexport default NonlinearNewton;","F:\\numerical-methods-js\\src\\components\\menu\\MethodType.js",[],"F:\\numerical-methods-js\\src\\components\\Graph.js",["343"],"F:\\numerical-methods-js\\src\\components\\matrix_utils.js",[],"F:\\numerical-methods-js\\src\\components\\MethodInfo.js",[],"F:\\numerical-methods-js\\src\\components\\methods\\test.js",[],{"ruleId":"344","severity":1,"message":"345","line":5,"column":8,"nodeType":"346","messageId":"347","endLine":5,"endColumn":38},{"ruleId":"344","severity":1,"message":"348","line":6,"column":8,"nodeType":"346","messageId":"347","endLine":6,"endColumn":35},{"ruleId":"344","severity":1,"message":"349","line":10,"column":8,"nodeType":"346","messageId":"347","endLine":10,"endColumn":27},{"ruleId":"344","severity":1,"message":"350","line":12,"column":8,"nodeType":"346","messageId":"347","endLine":12,"endColumn":24},{"ruleId":"344","severity":1,"message":"351","line":13,"column":8,"nodeType":"346","messageId":"347","endLine":13,"endColumn":24},{"ruleId":"344","severity":1,"message":"352","line":14,"column":8,"nodeType":"346","messageId":"347","endLine":14,"endColumn":25},{"ruleId":"344","severity":1,"message":"353","line":15,"column":8,"nodeType":"346","messageId":"347","endLine":15,"endColumn":29},{"ruleId":"344","severity":1,"message":"354","line":16,"column":8,"nodeType":"346","messageId":"347","endLine":16,"endColumn":29},{"ruleId":"344","severity":1,"message":"355","line":18,"column":8,"nodeType":"346","messageId":"347","endLine":18,"endColumn":26},{"ruleId":"344","severity":1,"message":"356","line":19,"column":8,"nodeType":"346","messageId":"347","endLine":19,"endColumn":28},{"ruleId":"344","severity":1,"message":"357","line":20,"column":8,"nodeType":"346","messageId":"347","endLine":20,"endColumn":28},{"ruleId":"344","severity":1,"message":"358","line":21,"column":8,"nodeType":"346","messageId":"347","endLine":21,"endColumn":26},{"ruleId":"344","severity":1,"message":"359","line":23,"column":8,"nodeType":"346","messageId":"347","endLine":23,"endColumn":32},{"ruleId":"344","severity":1,"message":"360","line":24,"column":8,"nodeType":"346","messageId":"347","endLine":24,"endColumn":28},{"ruleId":"344","severity":1,"message":"361","line":28,"column":8,"nodeType":"346","messageId":"347","endLine":28,"endColumn":32},{"ruleId":"344","severity":1,"message":"362","line":31,"column":8,"nodeType":"346","messageId":"347","endLine":31,"endColumn":34},{"ruleId":"344","severity":1,"message":"363","line":32,"column":8,"nodeType":"346","messageId":"347","endLine":32,"endColumn":34},{"ruleId":"344","severity":1,"message":"364","line":37,"column":8,"nodeType":"346","messageId":"347","endLine":37,"endColumn":28},{"ruleId":"344","severity":1,"message":"365","line":38,"column":8,"nodeType":"346","messageId":"347","endLine":38,"endColumn":25},{"ruleId":"344","severity":1,"message":"366","line":39,"column":8,"nodeType":"346","messageId":"347","endLine":39,"endColumn":27},{"ruleId":"344","severity":1,"message":"367","line":40,"column":8,"nodeType":"346","messageId":"347","endLine":40,"endColumn":29},{"ruleId":"344","severity":1,"message":"368","line":44,"column":7,"nodeType":"346","messageId":"347","endLine":44,"endColumn":29},{"ruleId":"344","severity":1,"message":"369","line":47,"column":7,"nodeType":"346","messageId":"347","endLine":47,"endColumn":26},{"ruleId":"344","severity":1,"message":"370","line":49,"column":7,"nodeType":"346","messageId":"347","endLine":49,"endColumn":18},{"ruleId":"344","severity":1,"message":"371","line":51,"column":7,"nodeType":"346","messageId":"347","endLine":51,"endColumn":15},{"ruleId":"344","severity":1,"message":"372","line":52,"column":7,"nodeType":"346","messageId":"347","endLine":52,"endColumn":16},{"ruleId":"344","severity":1,"message":"373","line":53,"column":7,"nodeType":"346","messageId":"347","endLine":53,"endColumn":15},{"ruleId":"344","severity":1,"message":"374","line":54,"column":7,"nodeType":"346","messageId":"347","endLine":54,"endColumn":20},{"ruleId":"344","severity":1,"message":"375","line":55,"column":7,"nodeType":"346","messageId":"347","endLine":55,"endColumn":20},{"ruleId":"344","severity":1,"message":"376","line":57,"column":7,"nodeType":"346","messageId":"347","endLine":57,"endColumn":17},{"ruleId":"344","severity":1,"message":"377","line":58,"column":7,"nodeType":"346","messageId":"347","endLine":58,"endColumn":24},{"ruleId":"344","severity":1,"message":"378","line":59,"column":7,"nodeType":"346","messageId":"347","endLine":59,"endColumn":24},{"ruleId":"344","severity":1,"message":"379","line":60,"column":7,"nodeType":"346","messageId":"347","endLine":60,"endColumn":17},{"ruleId":"344","severity":1,"message":"380","line":62,"column":7,"nodeType":"346","messageId":"347","endLine":62,"endColumn":23},{"ruleId":"344","severity":1,"message":"381","line":63,"column":7,"nodeType":"346","messageId":"347","endLine":63,"endColumn":19},{"ruleId":"344","severity":1,"message":"382","line":66,"column":7,"nodeType":"346","messageId":"347","endLine":66,"endColumn":24},{"ruleId":"344","severity":1,"message":"383","line":68,"column":7,"nodeType":"346","messageId":"347","endLine":68,"endColumn":23},{"ruleId":"344","severity":1,"message":"384","line":71,"column":7,"nodeType":"346","messageId":"347","endLine":71,"endColumn":25},{"ruleId":"344","severity":1,"message":"385","line":72,"column":7,"nodeType":"346","messageId":"347","endLine":72,"endColumn":25},{"ruleId":"344","severity":1,"message":"386","line":77,"column":7,"nodeType":"346","messageId":"347","endLine":77,"endColumn":19},{"ruleId":"344","severity":1,"message":"387","line":78,"column":7,"nodeType":"346","messageId":"347","endLine":78,"endColumn":16},{"ruleId":"344","severity":1,"message":"388","line":79,"column":7,"nodeType":"346","messageId":"347","endLine":79,"endColumn":18},{"ruleId":"344","severity":1,"message":"389","line":80,"column":7,"nodeType":"346","messageId":"347","endLine":80,"endColumn":20},{"ruleId":"344","severity":1,"message":"390","line":82,"column":7,"nodeType":"346","messageId":"347","endLine":82,"endColumn":10},{"ruleId":"344","severity":1,"message":"391","line":4,"column":8,"nodeType":"346","messageId":"347","endLine":4,"endColumn":13},{"ruleId":"344","severity":1,"message":"392","line":23,"column":8,"nodeType":"346","messageId":"347","endLine":23,"endColumn":15},{"ruleId":"344","severity":1,"message":"393","line":24,"column":8,"nodeType":"346","messageId":"347","endLine":24,"endColumn":11},{"ruleId":"344","severity":1,"message":"394","line":25,"column":8,"nodeType":"346","messageId":"347","endLine":25,"endColumn":16},{"ruleId":"395","severity":1,"message":"396","line":118,"column":21,"nodeType":"397","messageId":"398","endLine":118,"endColumn":42},{"ruleId":"344","severity":1,"message":"399","line":239,"column":11,"nodeType":"346","messageId":"347","endLine":239,"endColumn":19},{"ruleId":"344","severity":1,"message":"400","line":476,"column":9,"nodeType":"346","messageId":"347","endLine":476,"endColumn":22},{"ruleId":"344","severity":1,"message":"401","line":1,"column":8,"nodeType":"346","messageId":"347","endLine":1,"endColumn":14},{"ruleId":"344","severity":1,"message":"402","line":2,"column":10,"nodeType":"346","messageId":"347","endLine":2,"endColumn":22},{"ruleId":"344","severity":1,"message":"403","line":4,"column":8,"nodeType":"346","messageId":"347","endLine":4,"endColumn":18},{"ruleId":"344","severity":1,"message":"404","line":11,"column":8,"nodeType":"346","messageId":"347","endLine":11,"endColumn":20},{"ruleId":"344","severity":1,"message":"405","line":12,"column":8,"nodeType":"346","messageId":"347","endLine":12,"endColumn":17},{"ruleId":"344","severity":1,"message":"406","line":13,"column":8,"nodeType":"346","messageId":"347","endLine":13,"endColumn":22},{"ruleId":"344","severity":1,"message":"407","line":14,"column":8,"nodeType":"346","messageId":"347","endLine":14,"endColumn":16},{"ruleId":"344","severity":1,"message":"408","line":15,"column":8,"nodeType":"346","messageId":"347","endLine":15,"endColumn":20},{"ruleId":"344","severity":1,"message":"409","line":16,"column":8,"nodeType":"346","messageId":"347","endLine":16,"endColumn":11},{"ruleId":"344","severity":1,"message":"410","line":20,"column":8,"nodeType":"346","messageId":"347","endLine":20,"endColumn":14},{"ruleId":"344","severity":1,"message":"411","line":30,"column":8,"nodeType":"346","messageId":"347","endLine":30,"endColumn":16},{"ruleId":"344","severity":1,"message":"412","line":32,"column":8,"nodeType":"346","messageId":"347","endLine":32,"endColumn":18},{"ruleId":"344","severity":1,"message":"413","line":33,"column":8,"nodeType":"346","messageId":"347","endLine":33,"endColumn":31},{"ruleId":"344","severity":1,"message":"414","line":34,"column":10,"nodeType":"346","messageId":"347","endLine":34,"endColumn":20},{"ruleId":"344","severity":1,"message":"415","line":94,"column":7,"nodeType":"346","messageId":"347","endLine":94,"endColumn":17},{"ruleId":"344","severity":1,"message":"416","line":97,"column":7,"nodeType":"346","messageId":"347","endLine":97,"endColumn":18},{"ruleId":"344","severity":1,"message":"417","line":111,"column":7,"nodeType":"346","messageId":"347","endLine":111,"endColumn":20},{"ruleId":"344","severity":1,"message":"418","line":132,"column":7,"nodeType":"346","messageId":"347","endLine":132,"endColumn":20},{"ruleId":"395","severity":1,"message":"396","line":118,"column":21,"nodeType":"397","messageId":"398","endLine":118,"endColumn":42},{"ruleId":"419","replacedBy":"420"},{"ruleId":"421","replacedBy":"422"},{"ruleId":"395","severity":1,"message":"396","line":157,"column":25,"nodeType":"397","messageId":"398","endLine":157,"endColumn":46},{"ruleId":"395","severity":1,"message":"396","line":138,"column":25,"nodeType":"397","messageId":"398","endLine":138,"endColumn":46},{"ruleId":"395","severity":1,"message":"396","line":197,"column":25,"nodeType":"397","messageId":"398","endLine":197,"endColumn":46},{"ruleId":"395","severity":1,"message":"396","line":128,"column":21,"nodeType":"397","messageId":"398","endLine":128,"endColumn":42},{"ruleId":"395","severity":1,"message":"396","line":129,"column":21,"nodeType":"397","messageId":"398","endLine":129,"endColumn":42},{"ruleId":"344","severity":1,"message":"391","line":5,"column":8,"nodeType":"346","messageId":"347","endLine":5,"endColumn":13},{"ruleId":"395","severity":1,"message":"396","line":134,"column":21,"nodeType":"397","messageId":"398","endLine":134,"endColumn":42},{"ruleId":"344","severity":1,"message":"400","line":455,"column":9,"nodeType":"346","messageId":"347","endLine":455,"endColumn":22},{"ruleId":"395","severity":1,"message":"396","line":125,"column":21,"nodeType":"397","messageId":"398","endLine":125,"endColumn":42},{"ruleId":"344","severity":1,"message":"391","line":5,"column":8,"nodeType":"346","messageId":"347","endLine":5,"endColumn":13},{"ruleId":"344","severity":1,"message":"392","line":26,"column":8,"nodeType":"346","messageId":"347","endLine":26,"endColumn":15},{"ruleId":"344","severity":1,"message":"393","line":27,"column":8,"nodeType":"346","messageId":"347","endLine":27,"endColumn":11},{"ruleId":"344","severity":1,"message":"394","line":28,"column":8,"nodeType":"346","messageId":"347","endLine":28,"endColumn":16},{"ruleId":"395","severity":1,"message":"396","line":134,"column":21,"nodeType":"397","messageId":"398","endLine":134,"endColumn":42},{"ruleId":"344","severity":1,"message":"399","line":208,"column":11,"nodeType":"346","messageId":"347","endLine":208,"endColumn":19},{"ruleId":"344","severity":1,"message":"400","line":416,"column":9,"nodeType":"346","messageId":"347","endLine":416,"endColumn":22},{"ruleId":"395","severity":1,"message":"396","line":116,"column":21,"nodeType":"397","messageId":"398","endLine":116,"endColumn":42},{"ruleId":"395","severity":1,"message":"396","line":117,"column":21,"nodeType":"397","messageId":"398","endLine":117,"endColumn":42},{"ruleId":"395","severity":1,"message":"396","line":116,"column":21,"nodeType":"397","messageId":"398","endLine":116,"endColumn":42},{"ruleId":"344","severity":1,"message":"391","line":4,"column":8,"nodeType":"346","messageId":"347","endLine":4,"endColumn":13},{"ruleId":"344","severity":1,"message":"392","line":21,"column":8,"nodeType":"346","messageId":"347","endLine":21,"endColumn":15},{"ruleId":"344","severity":1,"message":"393","line":22,"column":8,"nodeType":"346","messageId":"347","endLine":22,"endColumn":11},{"ruleId":"344","severity":1,"message":"394","line":23,"column":8,"nodeType":"346","messageId":"347","endLine":23,"endColumn":16},{"ruleId":"344","severity":1,"message":"423","line":103,"column":11,"nodeType":"346","messageId":"347","endLine":103,"endColumn":22},{"ruleId":"395","severity":1,"message":"396","line":116,"column":21,"nodeType":"397","messageId":"398","endLine":116,"endColumn":42},{"ruleId":"344","severity":1,"message":"400","line":210,"column":9,"nodeType":"346","messageId":"347","endLine":210,"endColumn":22},{"ruleId":"344","severity":1,"message":"399","line":234,"column":11,"nodeType":"346","messageId":"347","endLine":234,"endColumn":19},{"ruleId":"344","severity":1,"message":"423","line":82,"column":11,"nodeType":"346","messageId":"347","endLine":82,"endColumn":22},{"ruleId":"344","severity":1,"message":"424","line":3,"column":37,"nodeType":"346","messageId":"347","endLine":3,"endColumn":44},{"ruleId":"395","severity":1,"message":"396","line":112,"column":21,"nodeType":"397","messageId":"398","endLine":112,"endColumn":42},{"ruleId":"344","severity":1,"message":"391","line":8,"column":8,"nodeType":"346","messageId":"347","endLine":8,"endColumn":13},{"ruleId":"344","severity":1,"message":"392","line":25,"column":8,"nodeType":"346","messageId":"347","endLine":25,"endColumn":15},{"ruleId":"344","severity":1,"message":"393","line":26,"column":8,"nodeType":"346","messageId":"347","endLine":26,"endColumn":11},{"ruleId":"344","severity":1,"message":"394","line":27,"column":8,"nodeType":"346","messageId":"347","endLine":27,"endColumn":16},{"ruleId":"344","severity":1,"message":"400","line":221,"column":9,"nodeType":"346","messageId":"347","endLine":221,"endColumn":22},{"ruleId":"344","severity":1,"message":"399","line":236,"column":11,"nodeType":"346","messageId":"347","endLine":236,"endColumn":19},{"ruleId":"395","severity":1,"message":"396","line":133,"column":21,"nodeType":"397","messageId":"398","endLine":133,"endColumn":42},{"ruleId":"395","severity":1,"message":"396","line":136,"column":21,"nodeType":"397","messageId":"398","endLine":136,"endColumn":45},{"ruleId":"344","severity":1,"message":"391","line":4,"column":8,"nodeType":"346","messageId":"347","endLine":4,"endColumn":13},{"ruleId":"395","severity":1,"message":"396","line":118,"column":21,"nodeType":"397","messageId":"398","endLine":118,"endColumn":42},{"ruleId":"344","severity":1,"message":"400","line":470,"column":9,"nodeType":"346","messageId":"347","endLine":470,"endColumn":22},{"ruleId":"344","severity":1,"message":"392","line":8,"column":8,"nodeType":"346","messageId":"347","endLine":8,"endColumn":15},{"ruleId":"344","severity":1,"message":"393","line":9,"column":8,"nodeType":"346","messageId":"347","endLine":9,"endColumn":11},{"ruleId":"344","severity":1,"message":"394","line":10,"column":8,"nodeType":"346","messageId":"347","endLine":10,"endColumn":16},{"ruleId":"344","severity":1,"message":"423","line":82,"column":11,"nodeType":"346","messageId":"347","endLine":82,"endColumn":22},{"ruleId":"344","severity":1,"message":"399","line":86,"column":11,"nodeType":"346","messageId":"347","endLine":86,"endColumn":19},{"ruleId":"344","severity":1,"message":"425","line":6,"column":31,"nodeType":"346","messageId":"347","endLine":6,"endColumn":39},{"ruleId":"344","severity":1,"message":"426","line":1,"column":9,"nodeType":"346","messageId":"347","endLine":1,"endColumn":26},{"ruleId":"344","severity":1,"message":"427","line":12,"column":8,"nodeType":"346","messageId":"347","endLine":12,"endColumn":12},{"ruleId":"428","severity":1,"message":"429","line":238,"column":57,"nodeType":"430","messageId":"431","endLine":238,"endColumn":83},{"ruleId":"428","severity":1,"message":"432","line":242,"column":53,"nodeType":"430","messageId":"431","endLine":242,"endColumn":79},{"ruleId":"395","severity":1,"message":"396","line":130,"column":21,"nodeType":"397","messageId":"398","endLine":130,"endColumn":42},{"ruleId":"395","severity":1,"message":"396","line":136,"column":21,"nodeType":"397","messageId":"398","endLine":136,"endColumn":42},{"ruleId":"395","severity":1,"message":"396","line":139,"column":21,"nodeType":"397","messageId":"398","endLine":139,"endColumn":42},{"ruleId":"433","severity":1,"message":"434","line":77,"column":8,"nodeType":"435","endLine":77,"endColumn":10,"suggestions":"436"},"no-unused-vars","'NonlinearFalsePositionMarkdown' is defined but never used.","Identifier","unusedVar","'NonlinearFixedPointMarkdown' is defined but never used.","'LinearGaussMarkdown' is defined but never used.","'LinearLUMarkdown' is defined but never used.","'LinearQRMarkdown' is defined but never used.","'LinearSVDMarkdown' is defined but never used.","'LinearInverseMarkdown' is defined but never used.","'LinearPenroseMarkdown' is defined but never used.","'EigenPowerMarkdown' is defined but never used.","'EigenInverseMarkdown' is defined but never used.","'EigenShiftedMarkdown' is defined but never used.","'EigenDiscsMarkdown' is defined but never used.","'OptiGoldenSearchMarkdown' is defined but never used.","'OptiGradientMarkdown' is defined but never used.","'IntegralMidpointMarkdown' is defined but never used.","'IntegralQuadratureMarkdown' is defined but never used.","'IntegralMonteCarloMarkdown' is defined but never used.","'OdeMultistepMarkdown' is defined but never used.","'OdeSystemMarkdown' is defined but never used.","'OdeShootingMarkdown' is defined but never used.","'OdeFiniteDiffMarkdown' is defined but never used.","'NonlinearFalsePosition' is assigned a value but never used.","'NonlinearFixedPoint' is assigned a value but never used.","'LinearGauss' is assigned a value but never used.","'LinearLU' is assigned a value but never used.","'LinearSVD' is assigned a value but never used.","'LinearQR' is assigned a value but never used.","'LinearInverse' is assigned a value but never used.","'LinearPenrose' is assigned a value but never used.","'EigenPower' is assigned a value but never used.","'EigenInversePower' is assigned a value but never used.","'EigenShiftedPower' is assigned a value but never used.","'EigenDiscs' is assigned a value but never used.","'OptiGoldenSearch' is assigned a value but never used.","'OptiGradient' is assigned a value but never used.","'DiffMultivariable' is assigned a value but never used.","'IntegralMidpoint' is assigned a value but never used.","'IntegralQuadrature' is assigned a value but never used.","'IntegralMonteCarlo' is assigned a value but never used.","'OdeMultistep' is assigned a value but never used.","'OdeSystem' is assigned a value but never used.","'OdeShooting' is assigned a value but never used.","'OdeFiniteDiff' is assigned a value but never used.","'FFT' is assigned a value but never used.","'Graph' is defined but never used.","'Tooltip' is defined but never used.","'Fab' is defined but never used.","'HelpIcon' is defined but never used.","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'openHelp' is assigned a value but never used.","'graphCallback' is assigned a value but never used.","'styles' is defined but never used.","'generatePath' is defined but never used.","'MethodInfo' is defined but never used.","'Autocomplete' is defined but never used.","'TextField' is defined but never used.","'InputAdornment' is defined but never used.","'ListItem' is defined but never used.","'ListItemText' is defined but never used.","'Box' is defined but never used.","'Dialog' is defined but never used.","'InfoIcon' is defined but never used.","'SearchIcon' is defined but never used.","'ArrowDropDownCircleIcon' is defined but never used.","'useHistory' is defined but never used.","'Transition' is assigned a value but never used.","'DialogTitle' is assigned a value but never used.","'DialogContent' is assigned a value but never used.","'searchOptions' is assigned a value but never used.","no-native-reassign",["437"],"no-negated-in-lhs",["438"],"'smallScreen' is assigned a value but never used.","'useMemo' is defined but never used.","'identity' is defined but never used.","'formatMatrixLatex' is defined but never used.","'Link' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'modifiedMatrix'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'modifiedOutput'.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'props.smallScreen' and 'updateGraph'. Either include them or remove the dependency array.","ArrayExpression",["439"],"no-global-assign","no-unsafe-negation",{"desc":"440","fix":"441"},"Update the dependencies array to be: [props.smallScreen, updateGraph]",{"range":"442","text":"443"},[2998,3000],"[props.smallScreen, updateGraph]"]